[
  {
    "objectID": "04-pratica.html",
    "href": "04-pratica.html",
    "title": "4¬† Modelo de Classifica√ß√£o",
    "section": "",
    "text": "4.1 Classifica√ß√£o em dados simples\nNeste cap√≠tulo, vamos aplicar os conceitos de Machine Learning (ML) em R usando o ecossistema tidymodels. Come√ßaremos com dados simples e sint√©ticos para entender a l√≥gica por tr√°s dos modelos de classifica√ß√£o, e depois aplicaremos esses mesmos conceitos a um conjunto de dados mais realista.\nVamos come√ßar gerando um conjunto de dados bidimensional simples que pode ser separado por uma linha reta. Isso nos permitir√° visualizar claramente como um modelo de regress√£o log√≠stica funciona.\n# 1. Gerar dados sint√©ticos para duas classes\n\n# Os dados da classe A s√£o gerados por: y = -2 * x + 5 (com algum ru√≠do)\n# Os dados da classe B s√£o gerados por: y = -2 * x + 6 (com algum ru√≠do)\nset.seed(42)\nn_obs &lt;- 1000\n\ndata_class_a &lt;- tibble(\n  x = rnorm(n_obs, mean = 2, sd = 1),\n  y = -2 * x + 5 + rnorm(n_obs, mean = 0, sd = 1)\n) %&gt;%\n  mutate(classe = \"A\")\n\ndata_class_b &lt;- tibble(\n  x = rnorm(n_obs, mean = 4, sd = 1),\n  y = -2 * x + 6 + rnorm(n_obs, mean = 2, sd = 1)\n) %&gt;%\n  mutate(classe = \"B\")\n\n# Unir os dataframes e misturar\ndados_simulados &lt;- bind_rows(data_class_a, data_class_b) %&gt;%\n  sample_frac(1)\n\nhead(dados_simulados)\n\n# A tibble: 6 √ó 3\n      x      y classe\n  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; \n1  3.33 -0.793 A     \n2  5.29 -0.231 B     \n3  5.44 -2.31  B     \n4  2.27  0.226 A     \n5  2.85  2.13  B     \n6  1.46  3.33  A\nPara entender melhor os dados que acabamos de criar, vamos visualiz√°-los. O gr√°fico a seguir mostra a distribui√ß√£o dos pontos no plano cartesiano. Podemos ver que as duas classes formam dois ‚Äúaglomerados‚Äù distintos.\nggplot(dados_simulados, aes(x = x, y = y)) +\n  geom_point(size = 3, alpha = 0.7)\nNesse pr√≥ximo gr√°fico, podemos observar cada uma das classes sendo representadas por uma cor. De fato, a diferen√ßa de aglomerados visto no gr√°fico anterior sugere a diferen√ßa entre os dois grupos.\nggplot(dados_simulados, aes(x = x, y = y, color = classe)) +\n  geom_point(size = 3, alpha = 0.7)",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Modelo de Classifica√ß√£o</span>"
    ]
  },
  {
    "objectID": "04-pratica.html#classifica√ß√£o-pinguins-do-arquip√©lago-palmer",
    "href": "04-pratica.html#classifica√ß√£o-pinguins-do-arquip√©lago-palmer",
    "title": "4¬† Modelo de Classifica√ß√£o",
    "section": "4.3 Classifica√ß√£o: Pinguins do arquip√©lago Palmer",
    "text": "4.3 Classifica√ß√£o: Pinguins do arquip√©lago Palmer\nAgora que voc√™ entendeu os conceitos b√°sicos, vamos aplicar o mesmo fluxo de trabalho em um conjunto de dados real: as medi√ß√µes dos pinguins da Ant√°rtida. Nosso objetivo ser√° classificar a esp√©cie do pinguim com base em suas caracter√≠sticas f√≠sicas.\n\n4.3.1 Conhe√ßa os pinguins üêß\n\n\n\nObra de¬†@allison_horst.\n\n\nOs palmerpenguinsdados cont√™m medi√ß√µes de tamanho de tr√™s esp√©cies de pinguins observadas em tr√™s ilhas no Arquip√©lago Palmer, na Ant√°rtida.\nEsses dados foram coletados entre 2007 e 2009 pela Dra. Kristen Gorman com o Programa de Pesquisa Ecol√≥gica de Longo Prazo da Esta√ß√£o Palmer , parte da Rede de Pesquisa Ecol√≥gica de Longo Prazo dos EUA . Os dados foram importados diretamente do Portal de Dados da Iniciativa de Dados Ambientais (EDI) e est√£o dispon√≠veis para uso sob licen√ßa CC0 (‚ÄúSem Direitos Reservados‚Äù), de acordo com a Pol√≠tica de Dados da Esta√ß√£o Palmer.\nPodemos acessar esses dados instalando a vers√£o lan√ßada do palmerpenguins do CRAN com:\n\nlibrary(palmerpenguins)\n\nWarning: pacote 'palmerpenguins' foi compilado no R vers√£o 4.4.3\n\n\n\nAnexando pacote: 'palmerpenguins'\n\n\nO seguinte objeto √© mascarado por 'package:modeldata':\n\n    penguins\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel‚Ä¶\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse‚Ä¶\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ‚Ä¶\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ‚Ä¶\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186‚Ä¶\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ‚Ä¶\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male‚Ä¶\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007‚Ä¶\n\n\n\n\n\n\n\nNosso objetivo ser√° classificar a esp√©cie do pinguim com base em suas caracter√≠sticas f√≠sicas.\n\n\n4.3.2 Preparando os Dados\nAntes de modelar, precisamos tratar os valores ausentes (NA) e dividir os dados.\n\n\n4.3.3 Aplica√ß√£o de um modelo de classifica√ß√£o\n\n# Criar um split treino/teste\nset.seed(123)\nsplit &lt;- initial_split(penguins, prop = 0.7, strata = species)\ntrain &lt;- training(split)\ntest &lt;- testing(split)\n\n\ndim(train)\n\n[1] 239   8\n\ndim(test)\n\n[1] 105   8\n\n\n\n\n4.3.4 Aplica√ß√£o de um modelo de classifica√ß√£o: Regress√£o Log√≠stica Multinomial\nVamos agora aplicar a regress√£o log√≠stica multinomial aos dados dos pinguins. Este modelo √© uma extens√£o da regress√£o log√≠stica bin√°ria, que permite classificar dados em tr√™s ou mais categorias.\n\n# 1. Definir o modelo de regress√£o log√≠stica multinomial\n# O 'set_engine(\"nnet\")' especifica o pacote que ser√° usado para o c√°lculo\nmodelo_multinomial &lt;- multinom_reg() %&gt;%\n  set_engine(\"nnet\") %&gt;%\n  set_mode(\"classification\")\n\n# 2. Criar o workflow (fluxo de trabalho)\n# O 'add_formula(species ~ .)' diz ao modelo para usar todas as outras vari√°veis\n# para prever a esp√©cie (species)\nworkflow_multinomial &lt;- workflow() %&gt;%\n  add_model(modelo_multinomial) %&gt;%\n  add_formula(species ~ .)\n\n# 3. Ajustar (treinar) o modelo com os dados de TREINO\n# O 'fit()' executa o treinamento do modelo\najustado_multinomial &lt;- fit(workflow_multinomial, data = train)\n\n# 4. Fazer previs√µes nos dados de TESTE\n# O 'predict()' usa o modelo treinado para prever a esp√©cie nos dados de teste\npred_multinomial &lt;- predict(ajustado_multinomial, new_data = test) %&gt;%\n  bind_cols(test)\n\n# 5. Avaliar o desempenho com a Matriz de Confus√£o\n# A 'conf_mat()' compara as previs√µes (.pred_class) com a realidade (species)\nmatriz_confusao_multinomial &lt;- conf_mat(pred_multinomial, truth = species, estimate = .pred_class)\nmatriz_confusao_multinomial\n\n           Truth\nPrediction  Adelie Chinstrap Gentoo\n  Adelie        44         0      0\n  Chinstrap      0        21      2\n  Gentoo         0         0     34\n\n\nA matriz de confus√£o acima mostra o desempenho do modelo em prever a esp√©cie de pinguim. Cada linha representa a esp√©cie real, e cada coluna representa a esp√©cie prevista. Os valores na diagonal mostram o n√∫mero de acertos do modelo para cada esp√©cie.\nPara uma avalia√ß√£o mais completa, tamb√©m podemos verificar as principais m√©tricas de classifica√ß√£o.\n\n# M√©tricas de desempenho\nmetrics(pred_multinomial, truth = species, estimate = .pred_class)\n\n# A tibble: 2 √ó 3\n  .metric  .estimator .estimate\n  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;\n1 accuracy multiclass     0.980\n2 kap      multiclass     0.969\n\n\n\n\n4.3.5 Treinando e Avaliando o Modelo de √Årvore de Decis√£o\nVamos usar uma √Årvore de Decis√£o para este exemplo, pois ela √© intuitiva e a visualiza√ß√£o da √°rvore ajuda a entender o processo de tomada de decis√£o.\n\n# Exemplo com √Årvore de Decis√£o (mais visual para iniciantes)\n\n# 1. Definir o modelo de √°rvore de decis√£o (rpart)\ntree_model &lt;- decision_tree() %&gt;%\n  set_engine(\"rpart\") %&gt;%\n  set_mode(\"classification\")\n\n# 2. Criar o workflow\ntree_workflow &lt;- workflow() %&gt;%\n  add_model(tree_model) %&gt;%\n  add_formula(species ~ .)\n\n# 3. Ajustar (treinar) o modelo\ntree_fit &lt;- fit(tree_workflow, data = train)\n\n# 4. Fazer previs√µes\ntree_pred &lt;- predict(tree_fit, new_data = test) %&gt;%\n  bind_cols(test)\n\n# 5. Gerar a matriz de confus√£o\nconf_mat(tree_pred, truth = species, estimate = .pred_class)\n\n           Truth\nPrediction  Adelie Chinstrap Gentoo\n  Adelie        45         0      1\n  Chinstrap      1        21      1\n  Gentoo         0         0     36\n\n\nVoc√™ tamb√©m pode extrair as m√©tricas de desempenho:\n\nmetrics(tree_pred, truth = species, estimate = .pred_class)\n\n# A tibble: 2 √ó 3\n  .metric  .estimator .estimate\n  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;\n1 accuracy multiclass     0.971\n2 kap      multiclass     0.955\n\n\n\n\n4.3.6 Visualizando a √Årvore de Decis√£o\nA beleza da √Årvore de Decis√£o √© que podemos visualizar o conjunto de regras que ela aprendeu. Cada n√≥ representa uma decis√£o baseada em uma vari√°vel (por exemplo, flipper_length_mm).\n\n# O pacote rpart.plot ajuda a visualizar a √°rvore\n# install.packages(\"rpart.plot\")\nlibrary(rpart.plot)\nrpart.plot(extract_fit_engine(tree_fit$fit$fit, roundint = FALSE))\n\nWarning: Cannot retrieve the data used to build the model (so cannot determine roundint and is.binary for the variables).\nTo silence this warning:\n    Call rpart.plot with roundint=FALSE,\n    or rebuild the rpart model with model=TRUE.\n\n\n\n\n\n\n\n\n\nA visualiza√ß√£o da √°rvore mostra o caminho que o modelo segue para classificar cada pinguim. Por exemplo, se o comprimento da nadadeira (flipper_length_mm) for maior ou igual a 207 mm e a profundidade do bico (bill_depth_mm) for maior ou igual a 17 mm, o pinguim ser√° classificado como Chistrap.\nEste exemplo ilustra como modelos de classifica√ß√£o podem ser usados para resolver problemas pr√°ticos e como a visualiza√ß√£o pode ser uma ferramenta poderosa para interpretar os resultados.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Modelo de Classifica√ß√£o</span>"
    ]
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1¬† Introdu√ß√£o",
    "section": "",
    "text": "1.1 O que √© ci√™ncia de dados?\nNeste primeiro cap√≠tulo, vamos mergulhar em alguns aspectos fundamentais para adentrarmos ao mundo da Ci√™ncia de Dados.\nAntes de colocarmos a m√£o na massa com o R e o RStudio nos pr√≥ximos cap√≠tulos, √© importante entendermos o que est√° por tr√°s dessa √°rea. Vamos explorar alguns conceitos principais, como intelig√™ncia artificial e aprendizado de m√°quina, e explorar os diferentes pap√©is e caminhos que uma carreira em dados pode oferecer. Ao final, voc√™ ter√° uma base s√≥lida para dar os primeiros passos e se preparar para a jornada pr√°tica que nos aguarda.\nA Ci√™ncia de Dados √© uma √°rea interdisciplinar que utiliza m√©todos cient√≠ficos, processos e algoritmos para extrair conhecimento e padr√µes de dados, tanto estruturados (organizados em planilhas) quanto n√£o estruturados (imagens, sons, sites, etc.). Em ess√™ncia, √© a combina√ß√£o de estat√≠stica, programa√ß√£o e conhecimento de dom√≠nio para solucionar problemas e guiar a tomada de decis√µes.\nO trabalho de um cientista de dados abrange todo o ciclo de vida dos dados, desde a coleta e a limpeza, passando pela an√°lise explorat√≥ria e a modelagem, at√© a comunica√ß√£o dos resultados. Essa jornada pode envolver a busca por dados em bases p√∫blicas (como as do IBGE), a participa√ß√£o em competi√ß√µes (como no Kaggle) ou a utiliza√ß√£o de reposit√≥rios colaborativos (como a Base dos Dados).\nDentro da √°rea, existem diferentes carreiras:",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html",
    "href": "02-fundamentos.html",
    "title": "2¬† Fundamentos de R",
    "section": "",
    "text": "2.1 O que s√£o R e RStudio?\nPara come√ßar essa jornada, o primeiro passo √© configurar o ambiente de trabalho. Isso envolve a instala√ß√£o de dois softwares distintos, mas que trabalham juntos: R e RStudio. Compreender o funcionamento de cada um e como eles se interagem √© fundamental para as pr√≥ximas etapas.\n√â comum que iniciantes confundam R e RStudio, mas esta distin√ß√£o √© crucial para o processo.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#o-que-s√£o-r-e-rstudio",
    "href": "02-fundamentos.html#o-que-s√£o-r-e-rstudio",
    "title": "2¬† Fundamentos de R",
    "section": "",
    "text": "R √© a linguagem de programa√ß√£o e o ambiente de software para computa√ß√£o estat√≠stica e gr√°ficos. Pode-se pensar que √© o ‚Äúmotor‚Äù que executa todos os c√°lculos, an√°lises e gera os gr√°ficos. Al√©m de tudo, √© um projeto de c√≥digo aberto, gratuito e mantido por uma vasta comunidade de desenvolvedores e estat√≠sticos ao redor do mundo.\nRStudio √© um Ambiente de Desenvolvimento Integrado (IDE, do ingl√™s Integrated Development Environment). Se o R √© o motor do carro, o RStudio1 √© o painel, o volante, e todo o interior que torna a condu√ß√£o do carro uma experi√™ncia agrad√°vel e gerenci√°vel. O RStudio fornece uma interface gr√°fica e amig√°vel que organiza o trabalho em R, facilitando a escrita de scripts (arquivos de c√≥digos), a visualiza√ß√£o de gr√°ficos, o gerenciamento de pacotes (bibliotecas) e muito mais. Embora seja poss√≠vel utilizar o R sem o RStudio, a utiliza√ß√£o do RStudio √© fortemente recomendada, pois deixa o processo de an√°lise muito mais interativo e organizado.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#instala√ß√£o-passo-a-passo",
    "href": "02-fundamentos.html#instala√ß√£o-passo-a-passo",
    "title": "2¬† Fundamentos de R",
    "section": "2.2 Instala√ß√£o passo a passo",
    "text": "2.2 Instala√ß√£o passo a passo\nA instala√ß√£o adequada dos programas √© um pr√©-requisito crucial. A ordem de instala√ß√£o √© importante: R deve ser instalado antes do RStudio.\n\nInstalando o R:\n\n\nAcesse o site do Comprehensive R Archive Network (CRAN)2, que √© o reposit√≥rio oficial para o R e seus pacotes.\nNa p√°gina inicial, selecione o link de download para o seu sistema operacional (Linux, macOS ou Windows).\nSiga as instru√ß√µes para baixar a vers√£o mais recente (‚Äúbase‚Äù). √â crucial baixar a vers√£o diretamente do CRAN, pois os gerenciadores de pacotes de alguns sistemas operacionais (como o get-apt do Ubuntu) podem fornecer vers√µes desatualizadas.\nExecute o arquivo de instala√ß√£o baixado e siga as instru√ß√µes padr√£o, aceitando as configura√ß√µes padr√£o.\n\n\n\nInstalando o RStudio:\n\n\nAp√≥s a instala√ß√£o do R, acesse o site da Posit e clique para baixar a vers√£o gratuita do RStudio Desktop.\nBaixe o instalador apropriado para o seu sistema operacional.\nExecute o arquivo de instala√ß√£o. O RStudio detectar√° automaticamente a instala√ß√£o do R existente.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#navegando-na-interface-do-rstudio",
    "href": "02-fundamentos.html#navegando-na-interface-do-rstudio",
    "title": "2¬† Fundamentos de R",
    "section": "2.3 Navegando na interface do RStudio",
    "text": "2.3 Navegando na interface do RStudio\nAo abrir o RStudio pela primeira vez, a interface se apresenta dividida em quatro pain√©is ou quadrantes principais, cada um com uma fun√ß√£o espec√≠fica:\n\nEditor de scripts (Superior esquerdo): Este √© o seu principal espa√ßo de trabalho. Aqui, voc√™ escrever√° e salvar√° seus scripts R (arquivos com extens√£o .R). Trabalhar em um script, em vez de digitar comandos diretamente no console, √© a base da ci√™ncia reprodut√≠vel, pois permite salvar, comentar e reutilizar seu c√≥digo.\nConsole (Inferior esquerdo): O console √© o c√≥digo R √© efetivamente executado. Voc√™ pode digitar os comandos diretamente nele para testes r√°pidos ou executar linhas de c√≥digos do seu script (utilizando o atalho Ctrl+Enter). A sa√≠da dos comandos tamb√©m aparecer√° aqui.\nAmbiente e Hist√≥rico (Superior direito): A aba Environment mostra todos os objetos (como datasets, vari√°veis, etc.) que foram criadas na sess√£o atual do R. J√° a aba History mant√©m um registro de todos os comandos utilizados.\nArquivos, Gr√°ficos, Pacotes e Ajuda (Inferior direita): Este painel multifuncional permite navegar pelos arquivos do seu computador (Files) , visualizar gr√°ficos gerados (Plots), gerenciar pacotes instalados (Packages), e acessar documenta√ß√µes de ajuda do R (Help).\n\n√â importante salientar que o RStudio permite customiza√ß√µes, como a altera√ß√£o das posi√ß√µes dos pain√©is.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#o-conceito-de-pacotes",
    "href": "02-fundamentos.html#o-conceito-de-pacotes",
    "title": "2¬† Fundamentos de R",
    "section": "2.4 O conceito de pacotes",
    "text": "2.4 O conceito de pacotes\nA grande for√ßa do R reside em seu ecossistema de pacotes. Um pacote √© a cole√ß√£o de fun√ß√µes, dados e documenta√ß√£o que estende as capacidades iniciais do R. Para qualquer tarefa estat√≠stica ou de manipula√ß√£o de dados que se possa imaginar, provavelmente existe algum pacote que a facilita.\n\n2.4.1 Instalando e Carregando Pacotes Essenciais\nExiste uma distin√ß√£o b√°sica a ser realizada entre instalar e carregar um pacote.\n\nInstala√ß√£o: √â o ato de baixar o pacote do CRAN e instal√°-lo no computador. Isso √© realizado apenas uma vez para cada pacote.\nCarregamento: √â o ato de carregar o pacote instalado em sua sess√£o do R de forma que as fun√ß√µes adicionais fiquem dispon√≠veis para uso. Isso precisa ser feito toda vez que uma sess√£o no R √© iniciada.\n\nPara este material, os pacotes centrais s√£o: tidyverse, lme4, lmerTest e nlme. Um dos m√©todos para instalar pacotes R no computador √© por meio da fun√ß√£o install.packages():\n\n\n# Instala o pacote tidyverse, que inclui dplyr, ggplot2 e outros\ninstall.packages(\"tidyverse\")\n\n# Instala o pacote para modelos lineares mistos\ninstall.packages(\"lme4\")\n\n# Instala outros pacotes para modelos mistos\ninstall.packages(\"lmerTest\")\ninstall.packages(\"nlme\")\n\nAp√≥s a instala√ß√£o, para usar as fun√ß√µes de um pacote, √© preciso carreg√°-lo com a fun√ß√£o library():\n\nlibrary(tidyverse)\n\nCabe ressaltar que, ao longo do uso de diversos pacotes, podem ocorrer conflitos de fun√ß√µes com o mesmo nome. Nesses casos, a solu√ß√£o mais pr√°tica √© utilizar a nota√ß√£o pacote::funcao para indicar explicitamente ao R de qual biblioteca desejamos chamar a fun√ß√£o.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#diret√≥rio-de-trabalho-e-projetos-rstudio",
    "href": "02-fundamentos.html#diret√≥rio-de-trabalho-e-projetos-rstudio",
    "title": "2¬† Fundamentos de R",
    "section": "2.5 Diret√≥rio de Trabalho e Projetos RStudio",
    "text": "2.5 Diret√≥rio de Trabalho e Projetos RStudio\nO diret√≥rio de trabalho √© a pasta no seu computador onde o R ir√° procurar por arquivos para ler e onde, tamb√©m, salvar√° os arquivos criados (como gr√°ficos, scripts e datasets modificados). √â poss√≠vel identificar o diret√≥rio atual atrav√©s do comando getwd() e, embora tamb√©m seja poss√≠vel defini-la manualmente com a fun√ß√£o setwd(\"caminho/para/sua/pasta\"), essa pr√°tica n√£o √© aconselh√°vel, visto que o uso de caminhos de arquivos absolutos torna o c√≥digo n√£o port√°vel; ou seja, ele n√£o ir√° funcionar se voc√™ mover a pasta do projeto ou tent√°-la execut√°-lo em outro computador.\nA solu√ß√£o moderna e robusta para esse problema √© a utiliza√ß√£o de Projetos RStudio. Um projeto RStudio (extens√£o .Rproj) √© um arquivo que voc√™ cria dentro de uma pasta do seu projeto de pesquisa. Ao abrir um projeto, o RStudio automaticamente define o diret√≥rio de trabalho para aquela pasta. Isso garante que todos os caminhos de arquivo do seu c√≥digo possam ser relativos √† raiz do projeto, tornando sua an√°lise totalmente reprodut√≠vel e compartilh√°vel de forma eficaz. Outra maneira de criar projetos √© atrav√©s do pr√≥prio RStudio, atrav√©s das seguintes instru√ß√µes File &gt; New Project &gt; New Directory &gt; New Project e nesta √∫ltima etapa, voc√™ escolher√° um nome para o projeto e a pasta de sua pesquisa, finalizando em Create Project. A cria√ß√£o de um projeto para cada an√°lise de pesquisa √© uma pr√°tica fundamental para a organiza√ß√£o e a reprodutibilidade cient√≠fica.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#r-b√°sico",
    "href": "02-fundamentos.html#r-b√°sico",
    "title": "2¬† Fundamentos de R",
    "section": "2.6 R B√°sico",
    "text": "2.6 R B√°sico\nA leitura desta sess√£o √© aconselhada para o leitor que nunca teve contato com o R. Os t√≥picos introduzidos s√£o especiais para a compreens√£o do que √© um dataframe, a estrutura dos datasets dentro do R, e quais opera√ß√µes estar√£o sendo realizadas quando estivermos efetuando filtragens e modifica√ß√µes de suas colunas. Tamb√©m s√£o importantes para a compreens√£o do que √© uma fun√ß√£o no R.\n\n2.6.1 Operadores Matem√°ticos\nOs operadores matem√°ticos, tamb√©m conhecidos por operadores bin√°rios, dentro do ambiente R soam como familiares. A Tabela¬†2.1 exibe os operadores mais b√°sicos utilizados.\nPara exemplificar como efetuar c√°lculos de express√µes matem√°ticas no R, suponha que desenhamos calcular o valor de: \\[2\\times 2 + \\frac{4 + 4}{2}.\\] Para isso, escrevemos 2*2 + (4+4)/2 no console para determinarmos o resultado\n\n2*2 + (4+4)/2\n\n[1] 8\n\n\n\n\nWarning: pacote 'knitr' foi compilado no R vers√£o 4.4.3\n\n\n\n\nTabela¬†2.1: Operadores matem√°ticos b√°sicos.\n\n\n\n\n\n\nOperadores\nDescri√ß√£o\n\n\n\n\n+\nAdi√ß√£o\n\n\n-\nSubtra√ß√£o\n\n\n*\nMultiplica√ß√£o\n\n\n/\nDivis√£o\n\n\n^\nExponencia√ß√£o\n\n\n\n\n\n\n\n\n\n\n\n\n2.6.2 Objetos e fun√ß√µes\nO R permite guardar valores dentro de um objeto. Um objeto √© simplesmente um nome que guarda uma determinada informa√ß√£o na mem√≥ria do computador, que √© criado por meio do operador &lt;-. Veja que no c√≥digo a seguir\n\nx &lt;- 10 # Salvando \"10\" em \"x\"\nx       # Avaliando o objeto \"x\"\n\n[1] 10\n\n\nfoi salvo que a informa√ß√£o que x carrega √© o valor 10. Portanto, toda vez que o objeto x for avaliado, o R ir√° devolver o valor 10.\n√â importante ressaltar que h√° regras para a nomea√ß√£o dos objetos, dentre elas, n√£o come√ßar com n√∫meros. Assim, todos os seguintes exemplos s√£o permitidos: x &lt;- 1, x1 &lt;- 1, meu_objeto &lt;- 1, meu.objeto &lt;- 1. Ainda, o R diferencia letras min√∫sculas de mai√∫sculas, ent√£o objetos como y e Y s√£o diferentes.\nEnquanto que os objetos s√£o nomes que salvam informa√ß√µes de valores, fun√ß√µes s√£o nomes que guardam informa√ß√µes de um c√≥digo R, retornando algum resultado programado. A sintaxe b√°sica de uma fun√ß√£o √© nome_funcao(arg1, arg2, ...). Os valores dentro dos par√™nteses s√£o chamados por argumentos, que s√£o informa√ß√µes necess√°rias para o bom funcionamento de uma fun√ß√£o. √Äs vezes, uma fun√ß√£o n√£o necessita do fornecimento de argumentos espec√≠ficos.\nUma fun√ß√£o simples, por√©m √∫til, √© a sum(). Ela consiste em somar os valores passados em seu argumento. Suponha que desejamos somar 1+2+3+4+5. Assim,\n\nsum(1,2,3,4,5)\n\n[1] 15\n\n\n√© poss√≠vel reparar que o resultado √© 15.\nA classe de um objeto √© muito importante na programa√ß√£o em R. √â a partir disso que as fun√ß√µes e operadores conseguem entender o que fazer com cada objeto. H√° uma infinidade de classes, dentre as mais conhecidas s√£o: numeric, character, data.frame, logical e factor. Para averiguar o tipo de classe, a fun√ß√£o class() retorna exatamente a classe do objeto.\n\nclass(\"a\")\n\n[1] \"character\"\n\nclass(1)\n\n[1] \"numeric\"\n\nclass(mtcars)\n\n[1] \"data.frame\"\n\nclass(TRUE)\n\n[1] \"logical\"\n\n\n\n\n2.6.3 Importanto dados\nUma atividade importante para qualquer an√°lise estat√≠stica que vier ser feita no R √© importante importar os dados para o ambiente de trabalho, que ficar√£o guardados dentro de um objeto no projeto RStudio ‚Äì afinal, como far√≠amos as an√°lises sem os dados? No contexto da Biologia, isso costuma significar ler arquivos com medidas de peso, contagens de indiv√≠duos, medidas de comprimento etc., geralmente armazenados em formatos de texto (.csv ou .tsv) ou planilhas (.xlsx). As principais fun√ß√µes para cada ocasi√£o de arquivo s√£o:\n\nCSV com cabe√ßalho:\n\n\ndados &lt;- read.csv(\"dados.csv\",\n  header = TRUE, # indica que h√° cabe√ßalho\n  sep    = \",\",  # separador v√≠rgula\n  stringsAsFactors = FALSE # evita convers√£o autom√°tica em fatores\n)\n\n\nTXT ou TSV com tabula√ß√£o:\n\n\ndados &lt;- read.delim(\"dadostsv\", \n  header = TRUE, \n  sep    = \"\\t\"\n)\n\n\nPlanilhas no Excel (arquivos .xlsx):\n\n\ndados &lt;- readxl::read_excel(\"dados.xlsx\",\n  sheet = \"Planilha1\" # aqui voc√™ escolhe a planilha a ser lida\n)\n\nRessaltamos, neste caso, a necessidade da utiliza√ß√£o da biblioteca readxl para que seja poss√≠vel lermos planilhas no R.\n\n\n2.6.4 Vetores e Data frames\nVetores s√£o uma estrutura fundamental dentro do R, em especial, √© a partir deles que os data frames s√£o constru√≠dos. Por defini√ß√£o, s√£o conjuntos indexados de valores e para cri√°-los, basta utilizar a fun√ß√£o c() com valores separados por v√≠rgula (ex.: c(1,2,4,10)). Para acessar um valor dentro de um determinado vetor, utiliza-se os colchetes []:\n\nvetor &lt;- c(\"a\", \"b\", \"c\")\n\n# Acessando valor \"b\"\nvetor[2]\n\n[1] \"b\"\n\n\nUm vetor s√≥ pode guardar um tipo de objeto e ele ter√° sempre a mesma classe dos objetos que guarda. Caso tentarmos misturar duas classes, o R vai apresentar o comportamento conhecido como coer√ß√£o.\n\nclass(c(1,2,3))\n\n[1] \"numeric\"\n\nclass(vetor)\n\n[1] \"character\"\n\nclass(c(1,2,\"a\",\"b\"))\n\n[1] \"character\"\n\n\nNeste caso, todos os elementos do vetor se transformaram em texto.\nAssim, tamb√©m, data frames s√£o de extrema import√¢ncia no R, visto que s√£o os objetos que guardam os dados e s√£o equivalentes a uma planilha do Excel. A principal caracter√≠stica √© possuir linha e colunas. Em geral, as colunas s√£o vetores de mesmo tamanho (ou dimens√£o). Um valor espec√≠fico de um data frame pode ser acessado, tamb√©m, via colchetes []:\n\nclass(mtcars)\n\n[1] \"data.frame\"\n\nmtcars[1,2]\n\n[1] 6\n\n\nmtcars √© um conjunto de dados muito conhecido na comunidade R.\n\n\n2.6.5 Fatores\nFatores s√£o uma classe de objetos no R criada para representar vari√°veis categ√≥ricas numericamente. A caracter√≠stica que define essa classe √© o atributo levels, que representam as poss√≠veis categorias de uma vari√°vel categ√≥rica.\nA t√≠tulo de exemplifica√ß√£o, considere o objeto sexo que cont√©m as informa√ß√µes do sexo de uma pessoa. As possibilidades s√£o: F (feminino) e M (masculino). Por padr√£o, o R interpreta essa vari√°vel como texto (character), no entanto, √© poss√≠vel transform√°-la em fator por meio da fun√ß√£o as.factor().\n\nsexo &lt;- c(\"F\", \"F\", \"M\", \"M\", \"F\")\nclass(sexo)\n\n[1] \"character\"\n\n# Transformando em fator\nclass(as.factor(sexo))\n\n[1] \"factor\"\n\nas.factor(sexo)\n\n[1] F F M M F\nLevels: F M\n\n\nObserva-se que a linha adicional Levels: F M indicam as categorias. Por padr√£o, o R ordena esses n√≠veis em ordem alfab√©tica. Para facilitar os c√°lculos e an√°lises, o R interpreta os n√≠veis categ√≥ricos como sendo n√∫meros distintos, sendo assim, dentro do nosso exemplo F representaria o n√∫mero 0 e M representaria o 1.\n\n\n2.6.6 Valores especiais\nValores como NA, NaN, Inf e NULL ocorrem frequentemente dentro do mundo da programa√ß√£o estat√≠stica no R. Em resumo:\n\nNA representa a Aus√™ncia de Informa√ß√£o. Suponha que o vetor idades que representa a idade de tr√™s pessoas. Uma situa√ß√£o que pode ocorrer √© idades &lt;- c(10, NA, NA). Portanto, n√£o √© sabido a idade das pessoas 2 e 3.\nNaN representa indefini√ß√µes matem√°ticas. Um exemplo t√≠pico √© o valor \\(\\log{-1}\\), do qual \\(x = -1\\) n√£o pertence aos poss√≠veis valores de sa√≠da da fun√ß√£o logar√≠tmica, gerando um NaN (Not a number).\n\n\nlog(-1)\n\nWarning in log(-1): NaNs produzidos\n\n\n[1] NaN\n\n\n\nInf representa um n√∫mero muito grande ou um limite matem√°tico. Exemplos:\n\n\n# N√∫mero muito grande\n10^510\n\n[1] Inf\n\n# Limite matem√°tico\n1/0\n\n[1] Inf\n\n\n\nNULL representa a aus√™ncia de um objeto. Muitas vezes define-se um objeto como nulo para dizer ao R que n√£o desejamos atribuir valores a ele.\n\n\n\n2.6.7 Pedindo ajuda\nUma das coisas que intimidam novos programadores, independente da linguagem utilizada, √© a ocorr√™ncia de erros. Neste sentido, o R pode ser um grande aliado, pois ele relata mensagens, erros e avisos sobre o c√≥digo no console, como se fosse uma esp√©cie de resposta e/ou comunica√ß√£o. As situa√ß√µes s√£o:\n\nError: em situa√ß√µes de erro leg√≠timo aparecer√° mensagens do tipo Error in ... e tentar√° explicar o que h√° de errado. Nestas situa√ß√µes o c√≥digo, geralmente, n√£o √© executado. Por exemplo: Error in ggplot(...) : could not find function \"ggplot\".\nWarning: em situa√ß√µes de avisos, o R exibir√° uma mensagem do tipo Warning: ... e tentar√° explicar o motivo do aviso. Geralmente, o c√≥digo ser√° executado, mas com algumas ressalvas. Por exemplo: Warning: Removed 2 rows containing missing values (geom_point).\nMessage: quando o texto exibido n√£o se enquadra nas duas op√ß√µes anteriores, dizemos que √© apenas uma mensagem. Pense, nessa situa√ß√£o, que tudo est√° acontecendo como o esperado e est√° tudo bem.\n\nQuando surgir qualquer uma dessas sa√≠das, n√£o estaremos perdidos, pois o R oferece mecanismos para encontrarmos respostas. Afinal, nem todo mundo decorou todas as fun√ß√µes ou argumentos. Os principais mecanismos s√£o:\n\n?fun√ß√£o ou help(fun√ß√£o) para consultar a documenta√ß√£o oficial.\n??termo e help.search(\"termo\") para buscas por palavras-chave.\n\nAl√©m disso, o RStudio oferece alguns Cheatsheets (resumo de c√≥digos) que podem ajudar com determinados pacotes. E, por fim, existem grandes comunidade online, tais como: Stack Overflow e RStudio Community dos quais tamb√©m podem serem √∫teis.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#footnotes",
    "href": "02-fundamentos.html#footnotes",
    "title": "2¬† Fundamentos de R",
    "section": "",
    "text": "Existem outras IDEs que podem ser utilizadas no lugar do RStudio, como o Visual Studio Code. No entanto, focaremos nosso estudo utilizando o RStudio.‚Ü©Ô∏é\nUm outro reposit√≥rio conhecido na comunidade cient√≠fica para pacotes com o intu√≠tuo de modelagem na biologia, em especial na gen√©tica, √© o Bioconductor.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html",
    "href": "03-tidyverse.html",
    "title": "3¬† Tidyverse",
    "section": "",
    "text": "3.1 Manipula√ß√£o de dados com o pacote dplyr\nO tidyverse (WICKHAM ET AL., 2019) √© um ecossistema de pacotes R que re√∫ne as tarefas essenciais de qualquer fluxo de trabalho em ci√™ncia de dados: importa√ß√£o, organiza√ß√£o, manipula√ß√£o, visualiza√ß√£o e programa√ß√£o. Seu principal objetivo √© criar uma sintaxe consistente e leg√≠vel, facilitando a comunica√ß√£o entre quem escreve o c√≥digo e quem o executa. Note-se que, embora o tidyverse cubra grande parte do fluxo de trabalho, ele n√£o inclui ferramentas espec√≠ficas de modelagem estat√≠stica.\nPara facilitar essa integra√ß√£o, o tidyverse utiliza intensamente do operador pipe1 (%&gt;%) , que passa o resultado de uma etapa diretamente para a pr√≥xima, evitando aninhamentos confusos. Ao carregar o pacote, diversos m√≥dulos s√£o automaticamente disponibilizados:\nEntre os principais est√£o:\nComo dito, muitos pacotes definem fun√ß√µes com nomes id√™nticos, sendo costatumum que o console exiba nomes como:\nUm pilar do tidyverse √© a ado√ß√£o do princ√≠pio tidy (WICKHAM, 2014), em que:\nNesse contexto, a entidade observacional √© o conceito central que define o que uma linha representa. Pode ser um paciente em um estudo cl√≠nico, um pa√≠s em dados econ√¥micos ou, como nos exemplos a seguir:\nA estrutura de dados que implementa essa filosofia no tidyverse √© o tibble. Ele √© a vers√£o moderna do data.frame, projetado para ser mais pr√°tico e informativo, exibindo resumos concisos dos dados e fornecendo diagn√≥sticos mais √∫teis.\nUma vez apresentada a filosofia e a estrutura de dados do tidyverse, o foco se volta para a aplica√ß√£o pr√°tica. A seguir, a concentra√ß√£o do material residir√° nos dois pacotes centrais do tidyverse: o dplyr, para manipula√ß√£o de dados, e o ggplot2, para a cria√ß√£o de gr√°ficos.\nO dplyr √© um pacote do tidyverse que fornece um conjunto de ferramentas robustas e intuitivas para manipula√ß√£o de dados. Os comandos oferecidos soam um tanto quanto intuitivos, correspondendo a√ß√µes comuns na √°rea de an√°lise de dados. Para explorar as principais fun√ß√µes ser√° utilizado o dataset penguins, focando em processos de filtragem, organiza√ß√£o, transforma√ß√£o e resumos dos dados, permitindo responder a perguntas b√°sicas sobre a biologia e ecologia dos pinguins.\nO primeiro passo a ser feito √© instalar a biblioteca palmerpenguins e, em seguida, carreg√°-la no ambiente de trabalho, para que possamos realizar uma inspe√ß√£o inicial na estrutura dos dados.\ninstall.packages(\"palmerpenguins\") # Realizar apenas uma √∫nica vez\nlibrary(palmerpenguins)\nPara carregarmos os dados sobre pinguins no ambiente de trabalho, podemos utilizar a fun√ß√£o data():\ndata(\"penguins\", package = \"palmerpenguins\")\nPodemos observar que no painel Environment do RStudio, aparece o objeto penguins, isso significa que o conjunto de dados est√° carregado no ambiente de trabalho e podemos dar in√≠cio nas inspe√ß√µes. O primeiro comando que ser√° visto √© o glimpse(). Ele exibe, de maneira pr√°tica e r√°pida, a estrutura do dataset como: dimens√£o (n√∫mero de linhas e colunas), o nome de cada coluna, o tipo de dado de cada coluna e as primeiras observa√ß√µes.\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel‚Ä¶\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse‚Ä¶\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ‚Ä¶\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ‚Ä¶\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186‚Ä¶\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ‚Ä¶\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male‚Ä¶\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007‚Ä¶\nA sa√≠da deste comando revela que existem 344 observa√ß√µes e 8 vari√°veis, sendo elas species, island, bill_length_mm, flipper_length_mm, body_mass_g, sex e year, com seus respectivos tipos, como factor para species e numeric para bill_length_mm. Al√©m disso, √© poss√≠vel observar dados ausentes em algumas vari√°veis, representados por NA. Em geral, nos datasets dispon√≠veis em pacotes R, √© poss√≠vel utilizar o comando help(penguins) para buscar informa√ß√µes sobre o conjunto de dados que ser√° trabalhado.\nExecutando o comando de ajuda, s√£o obtidas as seguintes informa√ß√µes sobre as vari√°veis:\nAdicionalmente, tamb√©m √© informado que os dados foram originalmente publicados no estudo de Gorman et al. (2014) e que essa pesquisa fez parte do programa Palmer Station Long-Term Ecological Research (LTER). Isso significa que o conjunto de dados que est√° sendo utilizado possui uma origem cient√≠fica real, ligada a quest√µes sobre como o ambiente e as diferen√ßas entre sexos afetam a vida dessas aves.\nA segunda fun√ß√£o que ser√° vista √© o select(). Frequentemente, um conjunto de dados cont√©m mais informa√ß√µes do que o necess√°rio para uma an√°lise espec√≠fica. Com isso em mente, a fun√ß√£o select() permite-nos selecionar colunas de interesse. Em geral, os argumentos s√£o os nomes das colunas.\npenguins %&gt;% \n  select(species, island, sex)\n\n# A tibble: 344 √ó 3\n   species island    sex   \n   &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt; \n 1 Adelie  Torgersen male  \n 2 Adelie  Torgersen female\n 3 Adelie  Torgersen female\n 4 Adelie  Torgersen &lt;NA&gt;  \n 5 Adelie  Torgersen female\n 6 Adelie  Torgersen male  \n 7 Adelie  Torgersen female\n 8 Adelie  Torgersen male  \n 9 Adelie  Torgersen &lt;NA&gt;  \n10 Adelie  Torgersen &lt;NA&gt;  \n# ‚Ñπ 334 more rows\nO dplyr tamb√©m oferece ‚Äúseletores auxiliares‚Äù que tornam a sele√ß√£o mais poderosa e flex√≠vel. Por exemplo, caso desejarmos selecionar todas as medidas biom√©tricas contidas no dataset que terminam com _mm, √© poss√≠vel usar a fun√ß√£o-argumento ends_with() dentro de select():\npenguins %&gt;% \n  select(\n    body_mass_g, ends_with(\"_mm\")\n  )\n\n# A tibble: 344 √ó 4\n   body_mass_g bill_length_mm bill_depth_mm flipper_length_mm\n         &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n 1        3750           39.1          18.7               181\n 2        3800           39.5          17.4               186\n 3        3250           40.3          18                 195\n 4          NA           NA            NA                  NA\n 5        3450           36.7          19.3               193\n 6        3650           39.3          20.6               190\n 7        3625           38.9          17.8               181\n 8        4675           39.2          19.6               195\n 9        3475           34.1          18.1               193\n10        4250           42            20.2               190\n# ‚Ñπ 334 more rows\nOutros seletores √∫teis incluem starts_with() e contains(). Para remover colunas, utiliza-se o sinal de menos (-). Por exemplo, deseja-se remover as colunas ano e island:\npenguins %&gt;% \n  select(-year, -island)\n\n# A tibble: 344 √ó 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt; \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            NA            NA                  NA          NA &lt;NA&gt;  \n 5 Adelie            36.7          19.3               193        3450 female\n 6 Adelie            39.3          20.6               190        3650 male  \n 7 Adelie            38.9          17.8               181        3625 female\n 8 Adelie            39.2          19.6               195        4675 male  \n 9 Adelie            34.1          18.1               193        3475 &lt;NA&gt;  \n10 Adelie            42            20.2               190        4250 &lt;NA&gt;  \n# ‚Ñπ 334 more rows\nAntes prosseguirmos para a pr√≥xima fun√ß√£o, vale destacar que o conjunto de dados penguins √© um objeto tibble dentro do R e, portanto, por mais que existam 344 observa√ß√µes, o tibble enxuga a visualiza√ß√£o para somente 10, al√©m de indicar quantas linhas ainda existem.\nA terceira fun√ß√£o √© o filter(). Enquanto select() trabalha nas colunas, o filter() trabalha nas linhas, permitindo-nos manter apenas as observa√ß√µes que satisfazem certas condi√ß√µes. √â aqui que √© poss√≠vel responder perguntas investigadas com rela√ß√£o aos dados. Por exemplo, para encontrar todos os pinguins da esp√©cie Adelie que vivem na ilha Torgersen:\npenguins %&gt;% \n  filter(\n      species == \"Adelie\", island == \"Torgersen\"\n    )\n\n# A tibble: 52 √ó 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ‚Ñπ 42 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nNeste exemplo, as condi√ß√µes separadas por v√≠rgula s√£o unidas por um ‚ÄúE‚Äù l√≥gico. Tamb√©m √© poss√≠vel utilizar o ‚ÄúOU‚Äù l√≥gico para determinar pinguins mais pesados (acima de 6000g) ou com bicos muito longos (mais de 55mm) atrav√©s do conectivo |:\npenguins %&gt;% \n  filter(\n    body_mass_g &gt; 6000 | bill_length_mm &gt; 55\n  )\n\n# A tibble: 6 √ó 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Gentoo    Biscoe           49.2          15.2               221        6300\n2 Gentoo    Biscoe           59.6          17                 230        6050\n3 Gentoo    Biscoe           55.9          17                 228        5600\n4 Gentoo    Biscoe           55.1          16                 230        5850\n5 Chinstrap Dream            58            17.8               181        3700\n6 Chinstrap Dream            55.8          19.8               207        4000\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nO filter() tamb√©m permite encontrar valores ausentes (NAs) em conjunto da fun√ß√£o is.na(). Por exemplo, deseja-se verificar quais pinguins n√£o tiveram seu sexo registrado:\npenguins %&gt;% \n  filter(is.na(sex))\n\n# A tibble: 11 √ó 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           NA            NA                  NA          NA\n 2 Adelie  Torgersen           34.1          18.1               193        3475\n 3 Adelie  Torgersen           42            20.2               190        4250\n 4 Adelie  Torgersen           37.8          17.1               186        3300\n 5 Adelie  Torgersen           37.8          17.3               180        3700\n 6 Adelie  Dream               37.5          18.9               179        2975\n 7 Gentoo  Biscoe              44.5          14.3               216        4100\n 8 Gentoo  Biscoe              46.2          14.4               214        4650\n 9 Gentoo  Biscoe              47.3          13.8               216        4725\n10 Gentoo  Biscoe              44.5          15.7               217        4875\n11 Gentoo  Biscoe              NA            NA                  NA          NA\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nA interpreta√ß√£o do NA √© relativa ao contexto dos dados. No caso das observa√ß√µes sobre os pinguins, os valores ausentes na vari√°vel sex permite identificar pinguins que n√£o tiveram o sexo avaliado, tornando um prov√°vel erro frustrante de coleta de dados para um objeto de investiga√ß√£o. O pacote tidyr, tamb√©m do tidyverse, oferece a fun√ß√£o drop_na(), que remove quaisquer linhas que contenham NAs, permitindo a cria√ß√£o de um dataset auxiliar:\npenguins_completo &lt;- penguins %&gt;% \n  drop_na()\nA quarta fun√ß√£o que ser√° apresentada √© arrange(), que permite reordenar as linhas do dataframe com base nos valores de uma ou mais colunas. Isso √© √∫til para encontrar extremos ou simplesmente para organizar a sa√≠da de uma forma mais l√≥gica. Para encontrar os pinguins mais leves, ordenamos pela massa corporal em ordem crescente (o padr√£o):\npenguins %&gt;% \n  arrange(body_mass_g)\n\n# A tibble: 344 √ó 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Chinstrap Dream              46.9          16.6               192        2700\n 2 Adelie    Biscoe             36.5          16.6               181        2850\n 3 Adelie    Biscoe             36.4          17.1               184        2850\n 4 Adelie    Biscoe             34.5          18.1               187        2900\n 5 Adelie    Dream              33.1          16.1               178        2900\n 6 Adelie    Torgers‚Ä¶           38.6          17                 188        2900\n 7 Chinstrap Dream              43.2          16.6               187        2900\n 8 Adelie    Biscoe             37.9          18.6               193        2925\n 9 Adelie    Dream              37.5          18.9               179        2975\n10 Adelie    Dream              37            16.9               185        3000\n# ‚Ñπ 334 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nPara ordenar os valores em ordem decrescente (do maior para o menor), utilizamos a fun√ß√£o auxiliar desc(), desta maneira, encontramos os pinguins mais pesados:\npenguins %&gt;% \n  arrange(desc(body_mass_g))\n\n# A tibble: 344 √ó 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo  Biscoe           49.2          15.2               221        6300\n 2 Gentoo  Biscoe           59.6          17                 230        6050\n 3 Gentoo  Biscoe           51.1          16.3               220        6000\n 4 Gentoo  Biscoe           48.8          16.2               222        6000\n 5 Gentoo  Biscoe           45.2          16.4               223        5950\n 6 Gentoo  Biscoe           49.8          15.9               229        5950\n 7 Gentoo  Biscoe           48.4          14.6               213        5850\n 8 Gentoo  Biscoe           49.3          15.7               217        5850\n 9 Gentoo  Biscoe           55.1          16                 230        5850\n10 Gentoo  Biscoe           49.5          16.2               229        5800\n# ‚Ñπ 334 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nTamb√©m √© poss√≠vel ordenar m√∫ltiplas colunas. Por exemplo, para encontrar o pinguim mais pesado dentro de cada esp√©cie:\npenguins %&gt;% \n  arrange(\n    species, # Primeiro por esp√©cie\n    desc(body_mass_g) # Depois por massa decrescente\n  )\n\n# A tibble: 344 √ó 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Biscoe              43.2          19                 197        4775\n 2 Adelie  Biscoe              41            20                 203        4725\n 3 Adelie  Torgersen           42.9          17.6               196        4700\n 4 Adelie  Torgersen           39.2          19.6               195        4675\n 5 Adelie  Dream               39.8          19.1               184        4650\n 6 Adelie  Dream               39.6          18.8               190        4600\n 7 Adelie  Biscoe              45.6          20.3               191        4600\n 8 Adelie  Torgersen           42.5          20.7               197        4500\n 9 Adelie  Dream               37.5          18.5               199        4475\n10 Adelie  Torgersen           41.8          19.4               198        4450\n# ‚Ñπ 334 more rows\n# ‚Ñπ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nA quinta fun√ß√£o e, com certeza, uma das mais funcionais √© a mutate(). Ela permite criar novas colunas (vari√°veis) que s√£o fun√ß√µes de colunas j√° existentes, sem modificar as originais. Por exemplo, suponha que desejamos mostrar somente as esp√©cies e massas de pinguins em quilogramas (kg):\npenguins %&gt;% \n  mutate(body_mass_kg = body_mass_g/1000) %&gt;% \n  select(species, body_mass_kg)\n\n# A tibble: 344 √ó 2\n   species body_mass_kg\n   &lt;fct&gt;          &lt;dbl&gt;\n 1 Adelie          3.75\n 2 Adelie          3.8 \n 3 Adelie          3.25\n 4 Adelie         NA   \n 5 Adelie          3.45\n 6 Adelie          3.65\n 7 Adelie          3.62\n 8 Adelie          4.68\n 9 Adelie          3.48\n10 Adelie          4.25\n# ‚Ñπ 334 more rows\nPodemos usar mutate() para criar categorias. A fun√ß√£o case_when() √© extremamente √∫til para criar classifica√ß√µes baseadas em condi√ß√µes l√≥gicas., Suponha que desejamos criar uma categoria de tamanho baseada na massa corporal:\npenguins %&gt;% \n  mutate(\n    size_category = case_when(\n      body_mass_g &gt; 4750 ~ \"Grande\",\n      body_mass_g &lt; 3500 ~ \"Pequeno\",\n      TRUE ~ \"M√©dio\"\n    )\n  ) %&gt;% \n  select(\n    species, body_mass_g, size_category\n  )\n\n# A tibble: 344 √ó 3\n   species body_mass_g size_category\n   &lt;fct&gt;         &lt;int&gt; &lt;chr&gt;        \n 1 Adelie         3750 M√©dio        \n 2 Adelie         3800 M√©dio        \n 3 Adelie         3250 Pequeno      \n 4 Adelie           NA M√©dio        \n 5 Adelie         3450 Pequeno      \n 6 Adelie         3650 M√©dio        \n 7 Adelie         3625 M√©dio        \n 8 Adelie         4675 M√©dio        \n 9 Adelie         3475 Pequeno      \n10 Adelie         4250 M√©dio        \n# ‚Ñπ 334 more rows\nAs fun√ß√µes group_by() e summarise() formam uma dupla formid√°vel para agrupar e resumir os dados, pertencendo ao cora√ß√£o da an√°lise de dados. A fun√ß√£o summarise() serve para calcular estat√≠sticas resumidas (como m√©dia, total, m√≠nimo etc.) e, quando usada em conjunto com group_by() permite gerar resumos por grupo.\nInicialmente, vamos utilizar o summarise() no dataset completo para obter estat√≠sticas globais. N√£o obstante, √© bom frisar a utiliza√ß√£o do argumento na.rm = TRUE para instruir a remo√ß√£o dos valores NA.\npenguins %&gt;% \n  summarise(\n    massa_media = mean(body_mass_g, na.rm = TRUE),\n    nadadeira_max = max(flipper_length_mm, na.rm = TRUE)\n  )\n\n# A tibble: 1 √ó 2\n  massa_media nadadeira_max\n        &lt;dbl&gt;         &lt;int&gt;\n1       4202.           231\nNo entanto, essas m√©tricas n√£o fornecem informa√ß√µes com rela√ß√£o as esp√©cies de pinguins. Para resolver isso e possibilitar que mais perguntas sejam respondidas, a fun√ß√£o group_by() permite que o R fa√ßa opera√ß√µes em subconjuntos. Por exemplo, suponha que desejamos determinar qual √© a massa corporal por esp√©cie:\npenguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(\n    massa_media_g = mean(body_mass_g, na.rm = TRUE)\n  )\n\n# A tibble: 3 √ó 2\n  species   massa_media_g\n  &lt;fct&gt;             &lt;dbl&gt;\n1 Adelie            3701.\n2 Chinstrap         3733.\n3 Gentoo            5076.\nPodemos fazer agrupamentos por m√∫ltiplas vari√°veis para investiga√ß√µes mais profundas. Por exemplo, considere que um pesquisador deseja explorar o dimorfismo sexual. Para isso, estat√≠sticas por esp√©cie e sexo ser√£o calculadas.\ntabela_resumo &lt;- penguins %&gt;% \n  drop_na(sex) %&gt;% \n  group_by(species, sex) %&gt;% \n  summarise(\n    contagem = n(),\n    massa_media_g = mean(body_mass_g),\n    massa_dp_g = sd(body_mass_g),\n    comp_bico_medio_mm = mean(bill_length_mm),\n    .groups = \"drop\"\n  )\ntabela_resumo\nTabela¬†3.1: Estat√≠sticas descritivas de caracter√≠sticas biom√©tricas de pinguins, agrupadas por esp√©cie e sexo.\nVale refor√ßar que a Tabela¬†3.1 foi gerada usando o dplyr, com as fun√ß√µes auxiliares n() para realizar a contagem de observa√ß√µes em cada grupo e drop_na(sex) para remover as observa√ß√µes onde o sexo √© desconhecido, permitindo avaliar dimorfismo sexual em todas as tr√™s esp√©cies, especialmente na massa corporal. O grande potencial dessa tabela √© obter respostas como:\nEsses resultados permitem tirar conclus√µes sobre algumas hip√≥teses biol√≥gicas.\nPor fim, a √∫ltima fun√ß√£o que ser√° abordada √© a recode(). Muitas vezes, os nomes das categorias nos conjuntos de dados n√£o s√£o ideais para a an√°lise ou apresenta√ß√£o em gr√°ficos. Podem ser longos demais, estarem em outro idioma ou simplesmente n√£o serem claros. Para isso, a fun√ß√£o recode() permite renomear valores de uma vari√°vel categ√≥rica de forma simples e direta. Por exemplo, suponha que desejamos traduzir os termos da vari√°vel sex da Tabela¬†3.1 para o portugu√™s:\ntabela_resumo %&gt;% \n  mutate(\n    sex = recode(sex,\n                 \"female\" = \"F√™mea\",\n                 \"male\" = \"Macho\")\n  )\nTabela¬†3.2: Tradu√ß√£o da vari√°vel sexo da Tabela¬†3.1.\nAs principais fun√ß√µes do pacote dplyr que foram vistas est√£o resumidas e descritas na Tabela Tabela¬†3.3 e agora que aprendemos como manipular os dados com o dplyr, podemos avan√ßar para a constru√ß√£o de gr√°ficos com o pacote ggplot2.\nTabela¬†3.3: Descri√ß√£o das principais fun√ß√µes do tidyverse.\n\n\n\n\n\n\nFun√ß√£o\nDescri√ß√£o\n\n\n\n\nglimpse()\nInspecionar conjuntos de dados.\n\n\nselect()\nSeleciona colunas pelo nome.\n\n\nfilter()\nFiltra linhas com base em seus valores.\n\n\narrange()\nReordena as linhas.\n\n\nmutate()\nCria novas colunas (vari√°veis).\n\n\ngroup_by()\nAgrupa os dados por uma ou mais vari√°veis.\n\n\nsummarise()\nReduz m√∫ltiplos valores a um √∫nico resumo.\n\n\nrecode()\nRenomeia categorias de vari√°veis.\n\n\nn()\nConta o n√∫mero de observa√ß√µes.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html#manipula√ß√£o-de-dados-com-o-pacote-dplyr",
    "href": "03-tidyverse.html#manipula√ß√£o-de-dados-com-o-pacote-dplyr",
    "title": "3¬† Tidyverse",
    "section": "",
    "text": "species: um fator que denota a esp√©cie do pinguim (Ad√©lie, Chinstrap ou Gentoo).\nisland: um fator que denota ilhas no Arquip√©lago Palmer na Ant√°rtica (Biscoe, Dream ou Torgersen).\nbill_length_mm: um n√∫mero que representa o comprimento do bico (em mil√≠metros).\nbill_depth_mm: um n√∫mero que representa a profundidade do bico (em mil√≠metros).\nflipper_length_mm: um n√∫mero que representa o comprimento da nadadeira (em mil√≠metros).\nbody_mass_g: um n√∫mero inteiro que representa a massa do animal (em gramas).\nsex: um fator que representa o sexo do animal (feminino ou masculino).\nyear: um n√∫mero inteiro que denota o ano de estudo (2007, 2008 ou 2009).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOs pinguins Gentoo s√£o, em m√©dia, os mais pesados.\nDentro de cada esp√©cie, os machos s√£o consistentemente mais pesados e t√™m bicos mais longo que as f√™meas.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html#visualiza√ß√£o-de-dados-com-ggplot2",
    "href": "03-tidyverse.html#visualiza√ß√£o-de-dados-com-ggplot2",
    "title": "3¬† Tidyverse",
    "section": "3.2 Visualiza√ß√£o de Dados com ggplot2",
    "text": "3.2 Visualiza√ß√£o de Dados com ggplot2\nSe o dplyr √© a gram√°tica da manipula√ß√£o de dados, possuindo fun√ß√µes essenciais para esse trabalho, o ggplot2 (WICKHAM, 2016) √© gram√°tica dos gr√°ficos, permitindo construir gr√°ficos por meio de camadas e oferecendo um sistema robusto e flex√≠vel para visualiza√ß√£o os dados. Nesta se√ß√£o, continuaremos utilizando os dados dos pinguins para explorar alguns insights visuais, desde gr√°ficos mais simples at√© os mais elaborados.\nTodo gr√°fico no ggplot2 √© constitu√≠do por tr√™s camadas essenciais:\n\nDados (data): O dataframe que cont√©m as informa√ß√µes a serem plotadas.\nMapeamento Est√©ticos (aes): A fun√ß√£o aes() (de aesthetics) descreve como as vari√°veis do nosso dataframe s√£o mapeadas para as propriedades visuais do gr√°fico. As est√©ticas mais comuns s√£o x e y (os eixos), mas tamb√©m incluem color (cor), shape (forma), size (tamanho) e alpha (transpar√™ncia/opacidade).\nObjetos geom√©tricos (geom): Os geoms definem como os dados s√£o representados visualmente. Por exemplo, geom_point() cria um gr√°fico de dispers√£o, geom_bar() cria um gr√°fico de barras, geom_line() cria um gr√°fico de linhas, e assim por diante.\n\n\n\n\n\n\n\n3.2.1 Estat√≠stica descritiva\nAntes de explorar as rela√ß√µes gr√°ficas, √© √∫til enfatizar e entender alguns conceitos essenciais da Estat√≠stica Descritiva como os tipos de vari√°veis, normas para tabelas e as defini√ß√µes de frequ√™ncias.\n\nEm geral, pode-se dizer que existem duas categorias de vari√°veis dentro da estat√≠stica:\n\nVari√°veis Qualitativas: Tamb√©m chamadas por vari√°veis categ√≥ricas e como o pr√≥prio nome diz, expressam qualidade e indicam categoria ou classifica√ß√£o a qual o objeto pertence. Se existir uma ordem entre as poss√≠veis categorias, a vari√°vel √© dita qualitativa ordinal. Caso contr√°rio, √© dita ser qualitativa nominal.\nVari√°veis Quantitativas: S√£o vari√°veis que tomam valores num√©ricos e expressam quantidade. Podem ser especificadas por Vari√°veis Discretas, quando assumem valores dentro de um conjunto enumer√°vel (quando √© poss√≠vel cont√°-las) ou por Vari√°veis Continuas, quando podem assumir infinitos valores de um intervalo n√£o numer√°vel2 (n√£o √© poss√≠vel contar o n√∫mero de valores dentro de um intervalo).\n\nAssim, para explorar e apresentar as informa√ß√µes contidas num conjunto de dados, precisamos resumir essas informa√ß√µes de forma que seja poss√≠vel enxerg√°-las rapidamente e adquirir conhecimento sobre o assunto.\nO resumo pode ser feito por meio de tabelas, gr√°ficos e c√°lculo de algumas quantidades representativas. O primeiro passo √© identificar o tipo de cada vari√°vel para aplicarmos a t√©cnica apropriada.\nNo entanto, antes de explorarmos a organiza√ß√£o dos dados em tabelas e gr√°ficos, s√£o necess√°rios conceitos sobre algumas m√©tricas essenciais denominadas por medidas resumo. Elas oferecem uma forma num√©rica e concisa de descrever as principais caracter√≠sticas das vari√°veis que ser√£o trabalhadas. Em geral, s√£o divididas em duas categorias essenciais: as medidas de tend√™ncia central, que informam onde o ‚Äúcentro‚Äù dos dados se localiza (como a m√©dia, mediana e moda), e as medidas de dispers√£o, que quantificam o qu√£o espalhados os dados est√£o (como a amplitude, o desvio padr√£o e a vari√¢ncia).\nA m√©dia aritm√©tica √© definida como sendo a soma de todos os valores dividida pelo n√∫mero de observa√ß√µes ou indiv√≠duos, ou seja, denotando-se as \\(n\\) observa√ß√µes de uma vari√°vel \\(X\\) por \\(x_1, x_2, \\dots, x_n\\) e a m√©dia por \\(\\bar{x}\\) temos: \\[\\bar{x} = \\frac{1}{n}\\sum_{i = 1}^{n} x_i\\] As principais propriedades da m√©dia s√£o:\n\n√â uma medidas simples e popular;\n√â sens√≠vel aos valores e discrepantes ou extremos. Portanto, na presen√ßa destes, a m√©dia pode n√£o ser uma representa√ß√£o de valores t√≠picos;\n√â o ponto de equil√≠brio da distribui√ß√£o;\nPara \\(k\\) constante e \\(X\\) vari√°vel, t√™m-se que a m√©dia de \\((X + k)\\) √© \\((\\bar{x} + k)\\) e, tamb√©m, a m√©dia de \\((kX)\\) √© \\((k\\bar{x})\\).\nPara \\(X\\) e \\(Y\\) vari√°veis independentes, a m√©dia de \\((X\\pm Y)\\) √© \\((\\bar{x} \\pm \\bar{y})\\).\n\nA mediana √© o valor do meio de uma distribui√ß√£o, ou seja, num histograma, √© o valor que deixa exatamente 50% dos dados de cada lado. Para determinar o valor exato da mediana √© necess√°rio ordenar todos os valores, do menor para o maior. Se \\(n\\), o n√∫mero de observa√ß√µes, √© √≠mpar ent√£o a mediana √© o valor que fica exatamente no centro; se \\(n\\) √© par, ent√£o √© a m√©dia dos dois valores centrais.\nAs principais propriedades da mediana s√£o:\n\nN√£o √© sens√≠vel a valores discrepantes e, portanto, √© a mais apropriada para representar valores t√≠picos quando a distribui√ß√£o √© assim√©trica;\nN√£o apresenta as propriedades matem√°ticas convenientes que a m√©dia possui.\n\nQuando a distribui√ß√£o √© sim√©trica, m√©dia e mediana s√£o iguais. No entanto, caso contr√°rio, a m√©dia estar√° mais afastada do meio que a mediana no sentido de uma cauda mais longa.\nA moda √© simplesmente o valor mais frequente da vari√°vel de estudo e para distribui√ß√µes sim√©tricas, m√©dia, mediana e moda possuem valores iguais.\nUma vez reconhecido o centro da distribui√ß√£o, √© necess√°rio ter uma ideia do quanto os valores est√£o distantes deste centro. Quanto mais heterog√™neo forem os dados, maior a dispers√£o e vice-versa. Dentre as m√©tricas que d√£o essa ideia, destacam-se:\nA amplitude definida pela diferen√ßa entre o maior e o menor valor. Al√©m disso, √© sens√≠vel a valores extremos. O primeiro quartil (\\(q_1\\)) e terceiro quartil (\\(q_3\\)), que dividem, respectivamente, o conjunto de dados em 25% e 75%. √â v√°lido ressaltar que todo conjunto de dados apresentam 3 quartis, dividindo o conjunto ordenado em quatro partes iguais, al√©m disso, o segundo quartil (\\(q_2\\)) √© igual a mediana. Essas medidas s√£o √∫teis na constru√ß√£o do gr√°fico de caixa (boxplot) que ser√° visto em sequ√™ncia.\nO desvio padr√£o (\\(s\\)) √© a medida de dispers√£o mais popular e mede a dispers√£o de todos os valores em rela√ß√£o √† m√©dia. Para calcul√°-lo, primeiramente calcula-se a vari√¢ncia, denotada por \\(s^2\\), que √© definida por: \\[s^2 = \\mathbb{V}(X) = \\frac{1}{n-1}\\sum_{i = 1}^{n}(x_i - \\bar{x})^2 = \\frac{1}{n-1}\\left(\\sum_{i = 1}^{n}x_i^2 - \\frac{\\left(\\sum_{i = 1}^{n} x_i\\right)^2}{n}\\right)\\] a diferen√ßa \\((x_i - \\bar{x})\\) √© chamada de desvio, representando o quanto o indiv√≠duo \\(i\\) desviou da m√©dia geral. A vari√¢ncia representa a m√©dia dos quadrados dos desvios em rela√ß√£o √† m√©dia. Al√©m disso, observe que a unidade de medida da vari√¢ncia √© a unidade da vari√°vel \\(x\\) ao quadrado, dificultando sua interpreta√ß√£o e, para lidar com isso, utiliza-se o desvio-padr√£o, visto que √© seu valor est√° na mesma escala de medida das observa√ß√µes, em que valores altos indica que os dados est√£o bastante dispersos e valores baixos, os indiv√≠duos est√£o pr√≥ximos da m√©dia, mostrando uma homogeneidade nos dados. As principais propriedades da vari√¢ncia (ou do desvio padr√£o) s√£o:\n\nPara \\(k\\) constante, \\(\\mathbb{V}(k) = 0\\), \\(\\mathbb{V}(k + X) = \\mathbb{V}(X)\\), \\(\\mathbb{V}(kX) = k^2\\mathbb{V}(X)\\);\nPara \\(X\\) e \\(Y\\) vari√°veis independentes, \\(\\mathbb{V}(X \\pm Y) = \\mathbb{V}(X) + \\mathbb{V}(Y)\\);\n√â sens√≠vel aos valores discrepantes e, portanto, s√≥ deve ser usada quando a distribui√ß√£o √© sim√©trica ou aproximadamente sim√©trica.\n\nPor fim, existe o coeficiente de vari√ß√£o (\\(\\text{cv}\\)), que √© uma medida de dispers√£o em termos de porcentagem da m√©dia: \\[\\text{cv} = \\frac{s}{\\bar{x}}\\times 100,\\] em que n√£o h√° unidade de medida e, portanto, serve como m√©trica de compara√ß√£o na varia√ß√£o de vari√°veis diferentes.\nDentro do R, a fun√ß√£o summary() √© a chave mestre que calcula quase todas as m√©tricas que foram vistas. Para exemplificar, selecionaremos apenas a vari√°vel bill_length do conjunto de dados penguins (Tabela¬†3.4).\n\npenguins %&gt;% \n  select(bill_length_mm) %&gt;% \n  summary()\n\n\n\n\n\nTabela¬†3.4: Sa√≠da da fun√ß√£o summary()\n\n\n\n\n\n\nVari√°vel\nMin\n1¬∫ Quad.\nMediana\nM√©dia\n3¬∫ Quad.\nMax\nNAs\n\n\n\n\nbill_length_mm\n32.1\n39.225\n44.45\n43.92193\n48.5\n59.6\n2\n\n\n\n\n\n\n\n\n\n\nEnquanto as medidas resumo nos fornecem valores pontuais para compreens√£o do centro e a dispers√£o, as tabelas oferecem uma vis√£o panor√¢mica da distribui√ß√£o dos dados. Organizar as informa√ß√µes de forma tabular √© o primeiro para visualizar as frequ√™ncias de cada categoria ou intervalo, complementando a an√°lise num√©rica anterior.\nAs normas gerais para constru√ß√£o de uma tabela envolvem:\n\nDevem ser auto-explicativas.\nDevem conter um t√≠tulo, que precisa ser simples e claro, indicando informa√ß√µes sobre os dados (do que, onde e quando foram coletados ‚Äì se forem relevantes).\n\nAl√©m das normas gerais, existem duas conven√ß√µes importantes a serem seguidas com rela√ß√£o ao t√≠tulo de tabelas e gr√°ficos:\n\nEm tabelas os t√≠tulos vem primeiro, em cima da tabela.\nEm gr√°ficos os t√≠tulos vem por √∫ltimo, embaixo do gr√°fico.\n\nSe necess√°rio, notas e fontes v√™m embaixo, em ambos os casos. Uma tabela come√ßa e termina com um tra√ßo horizontal e tra√ßos na vertical devem ser evitados, conforme visto na Tabela¬†3.1 por exemplo.\nUma forma adequada para resumir informa√ß√µes sobre uma vari√°vel numa tabela √© atrav√©s da constru√ß√£o de uma tabela de frequ√™ncias, que informa quais valores ou categorias a vari√°vel pode tomar, com suas respectivas frequ√™ncias. Quando a vari√°vel √© qualitativa, as frequ√™ncias v√£o revelar se temos categorias mais comuns (t√≠picas) e categorias raras ou se a distribui√ß√£o √© uniforme/homog√™nea. J√° quando a vari√°vel √© quantitativa, as frequ√™ncias revelar√£o os valores t√≠picos e/ou a distribui√ß√£o dos valores √© sim√©tricas ou assim√©trica.\nExistem alguns tipos de frequ√™ncia que podem ser utilizados para resumir as informa√ß√µes, dentre eles:\n\nFrequ√™ncia absoluta ou simplesmente frequ√™ncia (\\(f\\)): √© a contagem do n√∫mero de vezes que um valor ou categoria aparece.\nFrequ√™ncia relativa (\\(\\text{fr} = f/n\\)): quando esse valor √© multiplicado por \\(100\\), informa a porcentagem do aparecimento de uma determinada categoria sobre o n√∫mero total de contagem.\nFrequ√™ncia acumulada (\\(\\text{fa}\\)): √© a frequ√™ncia acumulada at√© um valor espec√≠fico.\nFrequ√™ncia acumulada relativa (\\(\\text{far} = \\text{fa}/n\\)): quando esse valor √© multiplicado por \\(100\\), informa a porcentagem acumulada do aparecimento de uma determinada categoria sobre o n√∫mero total de contagem.\n\nA Tabela¬†3.5 cont√©m as informa√ß√µes sobre as frequ√™ncias de cada esp√©cie de pinguim existente no conjunto de dados penguins. As informa√ß√µes b√°sicas que podem ser extra√≠das √© que entre as esp√©cies dentro do estudo sobre pinguins 44.2% s√£o Adelie, 36% s√£o Gentoo e 19.8% s√£o Chinstrap.\n\n\n\n\nTabela¬†3.5: Distribui√ß√£o de frequ√™ncias para as esp√©cies de Pinguins.\n\n\n\n\n\n\nEsp√©cies\nFrequ√™ncia\nFrequ√™ncia absoluta\nPorcentagem\n\n\n\n\nAdelie\n152\n0.442\n44.2\\%\n\n\nGentoo\n124\n0.360\n36\\%\n\n\nChinstrap\n68\n0.198\n19.8\\%\n\n\nTotal\n344\n1.000\n100\\%\n\n\n\n\n\n\n\n\n\n\nQuando a vari√°vel √© quantitativa e assume muitos valores distintos, para resumir e capturar o padr√£o da distribui√ß√£o, esses valores devem ser agrupados em intervalos. A quantidade de intervalos √© arbitr√°rio, no entanto, n√£o pode ser nem muito baixo e nem muito alto. O pr√≥ximo passo √© especificar os intervalos, contando quantos valores aparecem dentro de cada um deles.\nPara exemplificar, utilizaremos a vari√°vel body_mass_g de nosso conjunto de dados sobre os pinguins. Em geral, segue-se os passos:\n\nCalcular a amplitude (\\(A\\)) dos dados.\n\n\npenguins %&gt;% \n  summarise(\n    maior = max(body_mass_g, na.rm = TRUE),\n    menor = min(body_mass_g, na.rm = TRUE),\n    amplitude = max(body_mass_g, na.rm = TRUE) - min(body_mass_g, na.rm = TRUE))\n\n# A tibble: 1 √ó 3\n  maior menor amplitude\n  &lt;int&gt; &lt;int&gt;     &lt;int&gt;\n1  6300  2700      3600\n\n# Ou ainda\nA &lt;- penguins %&gt;% \n  summarise(\n    amplitude = diff(range(body_mass_g, na.rm = TRUE))\n  )\n\n\nEncontrar o comprimento aproximado de cada intervalo, dividindo \\(A\\) pelo n√∫mero de intervalos desejados.\n\n\nA/6\n\n  amplitude\n1       600\n\n\nA partir da Tabela¬†3.6 e pela coluna das frequ√™ncias relativas, observa-se que a distribui√ß√£o do peso √© assim√©trica. Em breve, isso ser√° observado graficamente.\n\n\n\n\nTabela¬†3.6: Distribui√ß√£o de frequ√™ncias para a massa corporal (g) dos pinguins.\n\n\n\n\n\n\nMassa corporal (g)\nFrequ√™ncia\nf.r. (\\%)\nf.a.r. (\\%)\n\n\n\n\n2700 $\\vdash$ 3300\n34\n9.94\\%\n9.94\\%\n\n\n3300 $\\vdash$ 3900\n110\n32.16\\%\n42.11\\%\n\n\n3900 $\\vdash$ 4500\n80\n23.39\\%\n65.5\\%\n\n\n4500 $\\vdash$ 5100\n60\n17.54\\%\n83.04\\%\n\n\n5100 $\\vdash$ 5700\n41\n11.99\\%\n95.03\\%\n\n\n5700 $\\vdash$ 6300\n17\n4.97\\%\n100\\%\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.2 Tipos de gr√°ficos\nAs distribui√ß√µes de frequ√™ncias podem ser representadas em gr√°ficos, que facilitam a interpreta√ß√£o visual do comportamento dos dados. Os gr√°ficos mais comuns, segundo o tipo de vari√°vel, s√£o:\n\nBarras ou colunas: apropriado para vari√°veis qualitativas e quantitativas discretas.\nSetores: qualitativas nominais com poucas categorias.\nHistograma: qualitativas cont√≠nuas.\nBox-plot: quantitativas.\nDiagrama de dispers√£o: relaciona duas quantitativas.\nGr√°fico de linhas: evolu√ß√£o de quantitativa ao longo do tempo ou espa√ßo.\n\nCom esse conhecimento em mente podemos prosseguir para as constru√ß√µes dos gr√°ficos utilizando o ggplot2\nO ggplot2 funciona com constru√ß√£o de ‚Äúcamadas‚Äù (layers). O comando ggplot() inicia um gr√°fico vazio.\n\nggplot()\n\n\n\n\n\n\n\n\nA partir deste gr√°fico vazio, podemos adicionar camadas de pontos, linhas, barras, caixas, entre outros. D√™ uma olhada no manual de refer√™ncia. Outros como tidyverse, ou Curso de R podem ajudar bastante! Explore o m√°ximo.\n\n3.2.2.1 Adicionando layers\nDe maneira geral, a sintaxe que vamos usar √© geom_yyy(data = dados, aes(x = x, y = y)), sendo que iremos substituir yyy por ‚Äúline‚Äù para linhas, ‚Äúpoint‚Äù para pontos e assim por diante.\nPor exemplo, para criar um plot da massa corporal x e comprimento da nadadeira\n\nggplot() +\n  geom_point(data = penguins_completo, aes(x = body_mass_g, y = flipper_length_mm))\n\n\n\n\n\n\n\n\nSe quisermos que os pontos tenham uma cor em particular, usamos\n\nggplot() +\n  geom_point(data = penguins_completo, aes(x = body_mass_g, y = flipper_length_mm), color = \"blue\")\n\n\n\n\n\n\n\n\nOu ainda, podemos utilizar a l√≥gica do tidyverse e aplicar um pipe para criar nosso gr√°fico.\n\npenguins_completo %&gt;% \n  ggplot() +\n  geom_point(aes(x = body_mass_g, y = flipper_length_mm), color = \"blue\")\n\n\n\n\n\n\n\n\nVeremos mais sobre esse tipo de gr√°fico depois.\n\n\n3.2.2.2 Visualizando uma √∫nica vari√°vel\nPara visualizar a distribui√ß√£o de uma vari√°vel cont√≠nua como a massa corporal, utiliza-se o histograma com a fun√ß√£o geom_histogram(). Como j√° foi visto, a escolha do n√∫mero de colunas √© arbitr√°rio e pode afetar significativamente a apar√™ncia e a interpreta√ß√£o do gr√°fico.\n\npenguins %&gt;% \n  ggplot(mapping = aes(x = body_mass_g))+\n    geom_histogram()\n\n\n\n\nDistribui√ß√£o da massa corporal (g) dos pinguins.\n\n\n\n\nMas esse gr√°fico √© muito feio, vamos ver como melhorar.\n\npenguins %&gt;% \n  ggplot(mapping = aes(x = body_mass_g))+\n    geom_histogram(color = \"white\", fill = \"steelblue\",\n                   breaks = seq(2700, 6300, by = 600), \n                   closed = \"left\")+\n    scale_x_continuous(\n      breaks = seq(2700, 6300, by = 600),\n      labels = seq(2700, 6300, by = 600),\n      limits = c(2700, 6300)\n    )+\n    labs(\n      x = \"Massa corporal (g)\",\n      y = \"Contagem\"\n    )+\n    ggthemes::theme_clean()\n\n\n\n\nDistribui√ß√£o da massa corporal (g) dos pinguins.\n\n\n\n\nObserve que a biblioteca ggthemes foi utilizada para melhorar o aspecto est√©tico do gr√°fico, fornecendo temas adicionais. Portanto, √© recomend√°vel instal√°-la e carreg√°-la no espa√ßo de trabalho.\n\n# install.packages(\"ggthemes\")\nlibrary(ggthemes)\n\nWarning: pacote 'ggthemes' foi compilado no R vers√£o 4.4.3\n\n\nPara vari√°veis categ√≥ricas, como species, usamos o geom_bar() para criar um gr√°fico de barras que mostra a contagem de observa√ß√µes em cada categoria.\n\npenguins %&gt;% \n  ggplot(mapping = aes(x = species, fill = species))+\n    geom_bar()+\n    labs(\n      x = \"Esp√©cie\",\n      y = \"N√∫mero de Indiv√≠duos\"\n    )+\n    labs(\n        x = \"Massa corporal (g)\",\n        y = \"Contagem\",\n        fill = \"Esp√©cies\"\n      )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\nDistribui√ß√£o de Pinguins por Esp√©cie.\n\n\n\n\n\n\n3.2.2.3 Rela√ß√µes entre vari√°veis\nO gr√°fico de dispers√£o √© a ferramenta cl√°ssica para explorar rela√ß√µes entre duas vari√°veis num√©ricas. Investigaremos a rela√ß√£o existente entre o comprimento da nadadeira e a massa corporal. A hip√≥tese √© que pinguins com nadadeiras maiores tamb√©m ser√£o mais pesados, uma rela√ß√£o positiva e intuitiva que serve como um excelente par√¢metro de partida.\n\npenguins %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g))+\n    geom_point()+\n    labs(\n      x = \"Comprimento da Nadadeira (mm)\",\n      y = \"Mass corporal (g)\"\n    )+\n  theme_clean()\n\n\n\n\n\n\n\nFigura¬†3.1: Rela√ß√£o entre o tamanho da nadadeira (mm) e o peso corporal (g) dos pinguins.\n\n\n\n\n\nA Figura¬†3.1 informa uma clara tend√™ncia positiva entre a nadadeira e o peso corporal dos pinguins. Mas ser√° que esse tend√™ncia √© a mesma para todas as esp√©cies? Para responder essa pergunta, atrav√©s da fun√ß√£o aes(), √© poss√≠vel adicionar est√©ticas adicionais como shape, color ou size para distinguir as esp√©cies no gr√°fico. O argumento a ser utilizado depender√° onde a imagem ser√° utilizada. Por exemplo, em uma revista cient√≠fica, que solicita gr√°ficos em preto e branco, √© aconselh√°vel utilizar shape ou size.\n\npenguins %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g, color = species))+\n    geom_point()+\n    labs(\n      x = \"Comprimento da Nadadeira (mm)\",\n      y = \"Massa corporal (g)\",\n      color = \"Esp√©cies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigura¬†3.2: Rela√ß√£o entre o tamanho da nadadeira (mm) e o peso corporal (g) por esp√©cie dos pinguins.\n\n\n\n\n\nA Figura¬†3.2 revela detalhes mais pertinentes, mostrando que a rela√ß√£o entre massa corporal e comprimento da nadadeira mant√™m-se positiva (n√≠vel de grupo).\nPara comparar a distribui√ß√£o de uma vari√°vel num√©rica entre diferentes categorias, o boxplot3 (geom_boxplot()) √© uma excelente ferramenta. Para isso, vamos comparar a distribui√ß√£o da massa corporal entre as tr√™s esp√©cies.\n\npenguins %&gt;% \n  ggplot(aes(x = species, y = body_mass_g, fill = species))+\n    geom_boxplot()+\n    labs(\n      x = \"Esp√©cies\",\n      y = \"Massa corporal (g)\",\n      fill = \"Esp√©cies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"none\")\n\n\n\n\nBoxplot para a massa corporal (g) por esp√©cies de pinguins.\n\n\n\n\nUma alternativa ao geom_boxplot() √© o geom_violin(), que traz um detalhamento sobre os dados de uma maneira mais simples. Adicionalmente, podemos utilizar o geom_jitter() para evitar a sobreposi√ß√£o dos dados, enriquecendo o visual do gr√°fico.\n\npenguins %&gt;% \n  ggplot(aes(x = species, y = body_mass_g, fill = species))+\n    geom_violin(alpha = 0.5)+\n    geom_jitter(width = 0.1, alpha = 0.5)+\n    labs(\n      x = \"Esp√©cie\",\n      y = \"Massa corporal (g)\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n3.2.3 T√©cnicas avan√ßadas de visualiza√ß√£o e comunica√ß√£o\nCom a base da constru√ß√£o de gr√°ficos vista anteriormente, √© poss√≠vel explorar t√©cnicas para criar gr√°ficos mais ricos e informativos, complementando informa√ß√µes descobertas de forma eficaz.\n\n\n3.2.4 Sub-gr√°ficos com facet_wrap()\nAs facetas permitem criar uma matriz de gr√°ficos, dividindo os dados com uma base em uma ou mais vari√°veis categ√≥ricas. Isso √© extremamente √∫til para compara√ß√µes. Para exemplificar, vamos utilizar o gr√°fico de dispers√£o e segment√°-lo para a vari√°vel sex.\n\npenguins %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  mutate(\n  sex = recode(sex,\n         \"female\" = \"F√™mea\",\n         \"male\" = \"Macho\")\n  ) %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g, color = species))+\n    geom_point()+\n    facet_wrap(~ sex)+\n    labs(\n      x = \"Comprimento da nadadeira (mm)\",\n      y = \"Massa corporal (g)\",\n      color = \"Esp√©cies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\nDistribui√ß√£o de massa corporal (g) por esp√©cie.\n\n\n\n\nNeste gr√°fico, fica evidente que os pinguins f√™meas possuem menos massa corporal que os machos e, quanto as esp√©cies, Gentoo √© que concentra a maior massa. Contudo, pode ser do interesse do pesquisador al√©m de verificar a massa corporal por sexo, tamb√©m incluir a vari√°vel island.\n\npenguins %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  mutate(\n  sex = recode(sex,\n         \"female\" = \"F√™mea\",\n         \"male\" = \"Macho\")\n  ) %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g, color = species))+\n    geom_point()+\n    facet_wrap(island ~ sex)+\n    labs(\n      x = \"Comprimento da nadadeira (mm)\",\n      y = \"Massa corporal (g)\",\n      color = \"Esp√©cies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigura¬†3.3: Distribui√ß√£o de massa corporal (g) nas ilhas por esp√©cie.\n\n\n\n\n\nA partir da Figura¬†3.3 √© poss√≠vel reparar que nem todas as esp√©cies est√£o presentes nas tr√™s ilhas simultaneamente. Al√©m disso, a ilha de Biscoe √© a que apresenta o maior percentual de massa corporal dos pinguins, isto √©, a esp√©cie Gentoo √© a predominante.\n\n\n\n\nGORMAN, Kristen B. et al. Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLOS ONE, v. 9, n. 3, p. e90081, 2014.\n\n\nWICKHAM, Hadley. Tidy Data. Journal of Statistical Software, v. 59, p. 1‚Äì23, set. 2014.\n\n\nWICKHAM, Hadley. Ggplot2. Cham: Springer International Publishing, 2016.\n\n\nWICKHAM, Hadley et al. Welcome to the Tidyverse. Journal of Open Source Software, v. 4, n. 43, p. 1686, nov. 2019.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html#footnotes",
    "href": "03-tidyverse.html#footnotes",
    "title": "3¬† Tidyverse",
    "section": "",
    "text": "A partir da vers√£o 4.1 do R, existe tamb√©m o operador pipe nativo |&gt;. No entanto, nesta apostila manteremos o uso de %&gt;%, amplamente adotado no contexto do tidyverse.‚Ü©Ô∏é\nTente contar os n√∫meros do conjunto \\(A = \\{1,2,3,4\\}\\) e, tamb√©m, de \\(B = [1,4]\\). Observe que no conjunto \\(A\\) h√° 4 elementos, enquanto em \\(B\\) h√° infinitos valores de 1 a 4.‚Ü©Ô∏é\nTamb√©m chamado por gr√°fico de caixas.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "GORMAN, Kristen B. et al. Ecological\nSexual Dimorphism and Environmental\nVariability within a Community of Antarctic\nPenguins (Genus Pygoscelis). PLOS\nONE, v. 9, n. 3, p. e90081, 2014.\n\n\nWICKHAM, Hadley. Tidy\nData. Journal of Statistical Software,\nv. 59, p. 1‚Äì23, set. 2014.\n\n\nWICKHAM, Hadley. Ggplot2.\nCham: Springer International Publishing, 2016.\n\n\nWICKHAM, Hadley et al. Welcome to the\nTidyverse. Journal of Open Source\nSoftware, v. 4, n. 43, p. 1686, nov. 2019.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Minicurso: Ci√™ncia de Dados com R ‚Äì Uma Introdu√ß√£o Pr√°tica",
    "section": "",
    "text": "Pref√°cio\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Pref√°cio"
    ]
  },
  {
    "objectID": "04-pratica.html#classifica√ß√£o-em-dados-simples",
    "href": "04-pratica.html#classifica√ß√£o-em-dados-simples",
    "title": "4¬† Modelo de Classifica√ß√£o",
    "section": "",
    "text": "4.1.1 Preparando os Dados para o Modelo\nAntes de treinar o modelo, √© uma pr√°tica essencial dividir o nosso conjunto de dados em dois subconjuntos: treino e teste.\n\nO conjunto de treino √© usado para ‚Äúensinar‚Äù o modelo a identificar padr√µes.\nO conjunto de teste √© usado para avaliar o desempenho do modelo em dados que ele nunca viu antes, garantindo uma avalia√ß√£o mais realista.\n\n\n# 2. Treinar um modelo de regress√£o log√≠stica\ndados_simulados$classe &lt;- as.factor(dados_simulados$classe)\n\nmodelo_logistico_simples &lt;- logistic_reg() %&gt;%\n  set_engine(\"glm\") %&gt;%\n  set_mode(\"classification\")\n  \n\n# 3. Dividir os dados em treino e teste\nsplit_simulado &lt;- initial_split(dados_simulados, prop = 0.7, strata = classe)\ntrain_simulado &lt;- training(split_simulado)\ntest_simulado &lt;- testing(split_simulado)\n\n\ndim(train_simulado)\n\n[1] 1400    3\n\ndim(test_simulado)\n\n[1] 600   3\n\n\n\n\n4.1.2 Treinando e Avaliando o Modelo de Regress√£o Log√≠stica\nAgora, vamos usar a biblioteca tidymodels para construir, treinar e avaliar o nosso modelo de Regress√£o Log√≠stica, que √© um algoritmo de classifica√ß√£o linear.\n\n# 4. Treinar o modelo de regress√£o log√≠stica nos dados de TREINO\nmodelo_logistico_simples &lt;- logistic_reg() %&gt;%\n  set_engine(\"glm\") %&gt;%\n  set_mode(\"classification\") %&gt;%\n  fit(classe ~ x + y, data = train_simulado)\n\n# Fazer previs√µes nos dados de TREINO\npreds_train &lt;- predict(modelo_logistico_simples, new_data = train_simulado) %&gt;%\n  bind_cols(train_simulado)\n\n\n\n4.1.3 Visualizando a Fronteira de Decis√£o\nA grande vantagem de usar dados sint√©ticos √© que podemos visualizar a ‚Äúfronteira de decis√£o‚Äù que o modelo encontrou para separar as duas classes. A Regress√£o Log√≠stica sempre encontrar√° uma linha reta para fazer essa separa√ß√£o.\n\n# 5. Fazer previs√µes nos dados de TESTE}\npreds_test &lt;- predict(modelo_logistico_simples, new_data = test_simulado) %&gt;%\n  bind_cols(test_simulado)\n\n\n# 6. Extrair os coeficientes para a reta de classifica√ß√£o\nintercept &lt;- modelo_logistico_simples$fit$coefficients[\"(Intercept)\"]\ncoef_x &lt;- modelo_logistico_simples$fit$coefficients[\"x\"]\ncoef_y &lt;- modelo_logistico_simples$fit$coefficients[\"y\"]\n\n# A reta de decis√£o √© onde a probabilidade √© 0.5, ou seja, -intercept = coef_x*x + coef_y*y\n# Isolamos 'y' para plotar a reta: y = (-coef_x/coef_y)*x - (intercept/coef_y)\nslope &lt;- -coef_x / coef_y\nintercept_line &lt;- -intercept / coef_y\n\n# 7. Visualizar os dados e a reta de classifica√ß√£o\nggplot(dados_simulados, aes(x = x, y = y, color = classe)) +\n  geom_point(size = 3, alpha = 0.7) +\n  geom_abline(intercept = intercept_line, slope = slope, linetype = \"dashed\", size = 1, color = \"black\") +\n  labs(\n    title = \"Classifica√ß√£o Linear com Regress√£o Log√≠stica\",\n    subtitle = \"A reta pontilhada √© a fronteira de decis√£o do modelo\",\n    x = \"Vari√°vel X\",\n    y = \"Vari√°vel Y\",\n    color = \"Classe\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n‚Ñπ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\n4.1.4 Avaliando o Desempenho do Modelo\nUma das ferramentas mais importantes para avaliar um modelo de classifica√ß√£o √© a Matriz de Confus√£o. Ela mostra o qu√£o bem o modelo classificou as amostras, comparando as classes previstas com as classes reais.\n\nVerdadeiros Positivos (TP): Predi√ß√µes corretas da classe positiva.\nVerdadeiros Negativos (TN): Predi√ß√µes corretas da classe negativa.\nFalsos Positivos (FP): Erro tipo I. Predi√ß√µes incorretas da classe positiva.\nFalsos Negativos (FN): Erro tipo II. Predi√ß√µes incorretas da classe negativa.\n\n\n# 8. Calcular a matriz de confus√£o\n\nmatriz_confusao &lt;- conf_mat(preds_train, truth = classe, estimate = .pred_class)\nmatriz_confusao\n\n          Truth\nPrediction   A   B\n         A 682  22\n         B  18 678\n\nmatriz_confusao_teste &lt;- conf_mat(preds_test, truth = classe, estimate = .pred_class)\nmatriz_confusao_teste\n\n          Truth\nPrediction   A   B\n         A 283   8\n         B  17 292\n\n\n\nautoplot(matriz_confusao_teste, type = \"heatmap\") +\n  labs(title = \"Matriz de Confus√£o (Dados de Teste)\")\n\n\n\n\n\n\n\n\nAl√©m da matriz de confus√£o, podemos usar outras m√©tricas para uma avalia√ß√£o mais completa:\n\nAcur√°cia (Accuracy): Propor√ß√£o de predi√ß√µes corretas em rela√ß√£o ao total.\nPrecis√£o (Precision): A propor√ß√£o de predi√ß√µes positivas que estavam corretas.\nRecall (Sensibilidade): A propor√ß√£o de casos positivos reais que foram identificados corretamente.\nF1-Score: M√©dia harm√¥nica de Precis√£o e Recall.\n\n\naccuracy(preds_test, truth = classe, estimate = .pred_class)\n\n# A tibble: 1 √ó 3\n  .metric  .estimator .estimate\n  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;\n1 accuracy binary         0.958\n\nprecision(preds_test, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric   .estimator .estimate\n  &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;\n1 precision binary         0.945\n\nrecall(preds_test, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 recall  binary         0.973\n\nf_meas(preds_test, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 f_meas  binary         0.959",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Modelo de Classifica√ß√£o</span>"
    ]
  },
  {
    "objectID": "04-pratica.html#classifica√ß√£o-com-dados-n√£o-lineares-√°rvore-de-decis√£o",
    "href": "04-pratica.html#classifica√ß√£o-com-dados-n√£o-lineares-√°rvore-de-decis√£o",
    "title": "4¬† Modelo de Classifica√ß√£o",
    "section": "4.2 2. Classifica√ß√£o com Dados N√£o-Lineares (√Årvore de Decis√£o)",
    "text": "4.2 2. Classifica√ß√£o com Dados N√£o-Lineares (√Årvore de Decis√£o)\nE se os dados n√£o puderem ser separados por uma linha reta? Vamos gerar um novo conjunto de dados onde as classes se ‚Äúcruzam‚Äù e testar a Regress√£o Log√≠stica novamente, para ent√£o compar√°-la com um modelo mais flex√≠vel: a √Årvore de Decis√£o.\n\n4.2.1 Gerando Dados N√£o-Lineares\n\n# 1. Gerar dados sint√©ticos para duas classes\n\nset.seed(42)\nn_obs &lt;- 1000\n\ndata_class_a &lt;- tibble(\n  x = rnorm(n_obs, mean = 4, sd = 1),\n  y = -2 * x + 16 + rnorm(n_obs, mean = 0, sd = 1)\n) %&gt;%\n  mutate(classe = \"A\")\n\ndata_class_b &lt;- tibble(\n  x = rnorm(n_obs, mean = 4, sd = 1),\n  y = 2 * x + rnorm(n_obs, mean = 2, sd = 1)\n) %&gt;%\n  mutate(classe = \"B\")\n\n# Unir os dataframes e misturar\ndados_simulados &lt;- bind_rows(data_class_a, data_class_b) %&gt;%\n  sample_frac(1)\n\nhead(dados_simulados)\n\n# A tibble: 6 √ó 3\n      x     y classe\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; \n1  5.33  6.21 A     \n2  5.29 14.9  B     \n3  5.44 13.4  B     \n4  4.27  7.23 A     \n5  2.85  7.55 B     \n6  3.46 10.3  A     \n\n\nVamos plotar esses novos dados.\n\nggplot(dados_simulados, aes(x = x, y = y)) +\n  geom_point(size = 3, alpha = 0.7) \n\n\n\n\n\n\n\n\nAgora colorindo cada uma das classes.\n\nggplot(dados_simulados, aes(x = x, y = y, color = classe)) +\n  geom_point(size = 3, alpha = 0.7) \n\n\n\n\n\n\n\n\nPerceba que as classes A e B n√£o s√£o separ√°veis por uma √∫nica linha reta.\n\n\n4.2.2 Regress√£o Log√≠stica em Dados N√£o-Lineares\nAgora, vamos tentar aplicar o mesmo modelo de Regress√£o Log√≠stica. A fronteira de decis√£o ser√° uma linha reta, mas veremos que ela n√£o conseguir√° separar bem as classes.\n\n# 2. Treinar um modelo de regress√£o log√≠stica\ndados_simulados$classe &lt;- as.factor(dados_simulados$classe)\n\n# 3. Dividir os dados em treino e teste\nsplit_simulado &lt;- initial_split(dados_simulados, prop = 0.7, strata = classe)\ntrain_simulado &lt;- training(split_simulado)\ntest_simulado &lt;- testing(split_simulado)\n\n\ndim(train_simulado)\n\n[1] 1400    3\n\ndim(test_simulado)\n\n[1] 600   3\n\n\n\n# 4. Treinar o modelo de regress√£o log√≠stica nos dados de TREINO\nmodelo_logistico_simples &lt;- logistic_reg() %&gt;%\n  set_engine(\"glm\") %&gt;%\n  set_mode(\"classification\") %&gt;%\n  fit(classe ~ x + y, data = train_simulado)\n\n# Fazer previs√µes nos dados de TREINO\npreds_train &lt;- predict(modelo_logistico_simples, new_data = train_simulado) %&gt;%\n  bind_cols(train_simulado)\n\n# 5. Fazer previs√µes nos dados de TESTE\npreds_test &lt;- predict(modelo_logistico_simples, new_data = test_simulado) %&gt;%\n  bind_cols(test_simulado)\n\n\n# 6. Extrair os coeficientes para a reta de classifica√ß√£o\nintercept &lt;- modelo_logistico_simples$fit$coefficients[\"(Intercept)\"]\ncoef_x &lt;- modelo_logistico_simples$fit$coefficients[\"x\"]\ncoef_y &lt;- modelo_logistico_simples$fit$coefficients[\"y\"]\n\n# A reta de decis√£o √© onde a probabilidade √© 0.5, ou seja, -intercept = coef_x*x + coef_y*y\n# Isolamos 'y' para plotar a reta: y = (-coef_x/coef_y)*x - (intercept/coef_y)\nslope &lt;- -coef_x / coef_y\nintercept_line &lt;- -intercept / coef_y\n\n# 7. Visualizar os dados e a reta de classifica√ß√£o\nggplot(dados_simulados, aes(x = x, y = y, color = classe)) +\n  geom_point(size = 3, alpha = 0.7) +\n  geom_abline(intercept = intercept_line, slope = slope, linetype = \"dashed\", size = 1, color = \"black\") +\n  labs(\n    title = \"Classifica√ß√£o Linear com Regress√£o Log√≠stica\",\n    subtitle = \"A reta pontilhada √© a fronteira de decis√£o do modelo\",\n    x = \"Vari√°vel X\",\n    y = \"Vari√°vel Y\",\n    color = \"Classe\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n# 8. Calcular a matriz de confus√£o\n\nmatriz_confusao &lt;- conf_mat(preds_train, truth = classe, estimate = .pred_class)\nmatriz_confusao\n\n          Truth\nPrediction   A   B\n         A 480 238\n         B 220 462\n\nmatriz_confusao &lt;- conf_mat(preds_test, truth = classe, estimate = .pred_class)\nmatriz_confusao\n\n          Truth\nPrediction   A   B\n         A 204 114\n         B  96 186\n\n\n\nautoplot(matriz_confusao, type = \"heatmap\")\n\n\n\n\n\n\n\n\nVamos ver algumas m√©tricas, como acur√°cia, precis√£o, recall e F1-score.\n\naccuracy(preds_test, truth = classe, estimate = .pred_class)\n\n# A tibble: 1 √ó 3\n  .metric  .estimator .estimate\n  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;\n1 accuracy binary          0.65\n\nprecision(preds_test, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric   .estimator .estimate\n  &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;\n1 precision binary         0.660\n\nrecall(preds_test, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 recall  binary          0.62\n\nf_meas(preds_test, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 f_meas  binary         0.639\n\n\nComo esperado, a matriz de confus√£o e as m√©tricas de desempenho mostram que o modelo teve dificuldade em separar os dados.\n\n\n4.2.3 √Årvore de Decis√£o em Dados N√£o-Lineares\nAgora, vamos usar uma √Årvore de Decis√£o, um modelo de classifica√ß√£o que n√£o √© restrito a fronteiras lineares.\n\n# 1. Definir o modelo de √°rvore de decis√£o (rpart)\ntree_model &lt;- decision_tree() %&gt;%\n  set_engine(\"rpart\") %&gt;%\n  set_mode(\"classification\")\n\n# 2. Criar o workflow\ntree_workflow &lt;- workflow() %&gt;%\n  add_model(tree_model) %&gt;%\n  add_formula(classe ~ .)\n\n# 3. Ajustar (treinar) o modelo\ntree_fit &lt;- fit(tree_workflow, data = train_simulado)\n\n# 4. Fazer previs√µes\ntree_pred &lt;- predict(tree_fit, new_data = test_simulado) %&gt;%\n  bind_cols(test_simulado)\n\n# 5. Gerar a matriz de confus√£o\nconf_mat(tree_pred, truth = classe, estimate = .pred_class)\n\n          Truth\nPrediction   A   B\n         A 254  37\n         B  46 263\n\n\n\n# 4. Fazer previs√µes nos dados de TREINO\ntree_pred_train &lt;- predict(tree_fit, new_data = train_simulado) %&gt;%\n  bind_cols(train_simulado)\n\n# 5. Gerar a matriz de confus√£o para os dados de TREINO\nconf_mat(tree_pred_train, truth = classe, estimate = .pred_class)\n\n          Truth\nPrediction   A   B\n         A 599  71\n         B 101 629\n\n\n\naccuracy(tree_pred, truth = classe, estimate = .pred_class)\n\n# A tibble: 1 √ó 3\n  .metric  .estimator .estimate\n  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;\n1 accuracy binary         0.862\n\nprecision(tree_pred, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric   .estimator .estimate\n  &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;\n1 precision binary         0.851\n\nrecall(tree_pred, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 recall  binary         0.877\n\nf_meas(tree_pred, truth = classe, estimate = .pred_class, event_level = \"second\")\n\n# A tibble: 1 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 f_meas  binary         0.864\n\n\nPerceba que a acur√°cia do modelo de √Årvore de Decis√£o foi significativamente maior! Isso acontece porque ele pode criar fronteiras de decis√£o complexas, que n√£o s√£o apenas linhas retas.\n\n\n4.2.4 Visualizando as Fronteiras de Decis√£o da √Årvore\nPara entender como a √Årvore de Decis√£o classificou os dados, vamos plotar as regi√µes de decis√£o. O resultado √© uma √°rea segmentada em ret√¢ngulos, onde cada ret√¢ngulo representa a previs√£o de uma classe.\n\n# 1. Criar uma grade de pontos para o plano 2D (x e y)\n# Definimos os limites da grade com base nos valores m√≠nimos e m√°ximos dos dados\ngrid &lt;- expand.grid(\n  x = seq(min(dados_simulados$x) - 1, max(dados_simulados$x) + 1, length.out = 100),\n  y = seq(min(dados_simulados$y) - 1, max(dados_simulados$y) + 1, length.out = 100)\n)\n\n# 2. Fazer as previs√µes para cada ponto na grade usando o modelo de √°rvore\ngrid_preds_tree &lt;- predict(tree_fit, new_data = grid, type = \"class\") %&gt;%\n  bind_cols(grid)\n\n# 3. Plotar as fronteiras de decis√£o e os dados originais\nggplot() +\n  # Camada para as fronteiras de decis√£o\n  geom_raster(data = grid_preds_tree, aes(x = x, y = y, fill = .pred_class), alpha = 0.5) +\n  # Camada para os pontos de dados originais\n  geom_point(data = dados_simulados, aes(x = x, y = y, color = classe), size = 2) +\n  # Adicionando r√≥tulos e t√≠tulo\n  labs(\n    title = \"Fronteiras de Decis√£o da √Årvore de Decis√£o\",\n    subtitle = \"Regi√µes de previs√£o do modelo de √°rvore\",\n    x = \"Vari√°vel X\",\n    y = \"Vari√°vel Y\",\n    fill = \"Classe Prevista\",\n    color = \"Classe Real\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nPodemos visualizar a √°rvore com as perguntas feitas.\n\n# O pacote rpart.plot ajuda a visualizar a √°rvore\n# install.packages(\"rpart.plot\")\nlibrary(rpart.plot)\n\nWarning: pacote 'rpart.plot' foi compilado no R vers√£o 4.4.3\n\n\nCarregando pacotes exigidos: rpart\n\n\n\nAnexando pacote: 'rpart'\n\n\nO seguinte objeto √© mascarado por 'package:dials':\n\n    prune\n\nrpart.plot(extract_fit_engine(tree_fit$fit$fit, roundint = FALSE))\n\nWarning: Cannot retrieve the data used to build the model (so cannot determine roundint and is.binary for the variables).\nTo silence this warning:\n    Call rpart.plot with roundint=FALSE,\n    or rebuild the rpart model with model=TRUE.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Modelo de Classifica√ß√£o</span>"
    ]
  },
  {
    "objectID": "01-intro.html#o-que-√©-ci√™ncia-de-dados",
    "href": "01-intro.html#o-que-√©-ci√™ncia-de-dados",
    "title": "1¬† Introdu√ß√£o",
    "section": "",
    "text": "Cientista de Dados: Foca na an√°lise e na modelagem de dados para extrair informa√ß√µes, usando conhecimentos de estat√≠stica e algoritmos de machine learning.\nEngenheiro de Dados (Data Engineer): Respons√°vel por construir e manter a infraestrutura (bancos de dados, pipelines) que permite que os dados sejam coletados, processados e acessados de forma eficiente.\nAnalista de Dados (Data Analyst): Focado em explorar e visualizar dados para responder a perguntas de neg√≥cio, geralmente usando ferramentas como o Power BI ou o Tableau.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o</span>"
    ]
  },
  {
    "objectID": "01-intro.html#ia-aprendizado-de-m√°quina-e-aprendizado-profundo",
    "href": "01-intro.html#ia-aprendizado-de-m√°quina-e-aprendizado-profundo",
    "title": "1¬† Introdu√ß√£o",
    "section": "1.2 IA, Aprendizado de M√°quina e Aprendizado Profundo",
    "text": "1.2 IA, Aprendizado de M√°quina e Aprendizado Profundo\nEsses termos s√£o frequentemente usados de forma intercambi√°vel, mas t√™m significados distintos. Pense neles como caixas dentro de caixas:\n\nIntelig√™ncia Artificial (IA): O conceito mais amplo. √â a ci√™ncia de criar m√°quinas ou programas que podem simular a intelig√™ncia humana, resolvendo problemas, tomando decis√µes e interagindo com o ambiente.\nAprendizado de M√°quina (Machine Learning - ML): Um subcampo da IA. Trata-se da constru√ß√£o de modelos que aprendem padr√µes a partir de dados, sem serem explicitamente programados para cada tarefa. Em vez de seguir um conjunto de regras fixas, o modelo aprende e se ajusta com base nos exemplos que recebe.\nAprendizado Profundo (Deep Learning - DL): Um subcampo do ML. Utiliza redes neurais artificiais com m√∫ltiplas camadas (por isso o ‚Äúprofundo‚Äù) para analisar dados. √â especialmente eficaz em tarefas complexas, como reconhecimento de imagem e processamento de linguagem natural.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o</span>"
    ]
  },
  {
    "objectID": "01-intro.html#o-que-√©-aprendizado-de-m√°quina",
    "href": "01-intro.html#o-que-√©-aprendizado-de-m√°quina",
    "title": "1¬† Introdu√ß√£o",
    "section": "1.3 O que √© aprendizado de m√°quina?",
    "text": "1.3 O que √© aprendizado de m√°quina?\nO Aprendizado de M√°quina (em ingl√™s Machine Learning, ML) √© a capacidade de um sistema computacional aprender e melhorar a partir da experi√™ncia, ou seja, a partir dos dados. Ao inv√©s de escrever regras manuais e inflex√≠veis para cada situa√ß√£o, voc√™ ‚Äútreina‚Äù um modelo para que ele descubra e generalize os padr√µes presentes nos dados.\nImagine que voc√™ quer criar um filtro de spam para e-mails. A abordagem cl√°ssica seria escrever uma regra: ‚ÄúSe o e-mail contiver as palavras ‚Äòganhar dinheiro‚Äô, ‚Äòmilion√°rio‚Äô e ‚Äòclique aqui‚Äô, marque-o como spam‚Äù. A abordagem de machine learning √© diferente: voc√™ alimenta o modelo com milhares de e-mails j√° classificados como ‚Äúspam‚Äù ou ‚Äún√£o spam‚Äù e deixa que ele aprenda quais caracter√≠sticas s√£o mais importantes para fazer essa distin√ß√£o. O modelo pode descobrir padr√µes muito mais sutis e complexos que um humano n√£o conseguiria definir em regras.\n\n1.3.1 Por que o ML √© importante?\nO machine learning impulsiona muitas das tecnologias que usamos diariamente, como:\n\nSistemas de recomenda√ß√£o: A Netflix sugere filmes e o Spotify recomenda m√∫sicas baseados no que voc√™ j√° consumiu.\nDetec√ß√£o de fraude: Bancos usam modelos de ML para identificar transa√ß√µes suspeitas em tempo real.\nCarros aut√¥nomos: Ve√≠culos que usam ML para reconhecer objetos, pedestres e sinais de tr√¢nsito, tomando decis√µes instant√¢neas.\nAvan√ßos cient√≠ficos: O AlphaFold 2, por exemplo, usou aprendizado profundo para prever a estrutura de prote√≠nas com uma precis√£o incr√≠vel, acelerando a pesquisa em biologia e medicina.\n\n\n\n1.3.2 Tipos de Aprendizado de M√°quina\n\nAprendizado Supervisionado: O modelo aprende a partir de dados que j√° possuem um ‚Äúr√≥tulo‚Äù ou ‚Äúresposta‚Äù correta. O objetivo √© prever essa resposta para novos dados. √â o caso do filtro de spam, onde voc√™ sabe quais e-mails s√£o spam e quais n√£o s√£o.\nAprendizado N√£o Supervisionado: O modelo trabalha com dados que n√£o t√™m r√≥tulos. O objetivo √© encontrar padr√µes e estruturas ocultas. Um exemplo √© a segmenta√ß√£o de clientes, onde voc√™ agrupa clientes com comportamentos parecidos, sem saber de antem√£o qual √© o ‚Äúgrupo‚Äù correto.\nAprendizado Semi-Supervisionado: Uma combina√ß√£o dos dois anteriores. O modelo usa um conjunto pequeno de dados rotulados e um grande conjunto de dados n√£o rotulados para aprender padr√µes. √ötil quando rotular dados √© caro ou demorado.\nAprendizado por Refor√ßo: O modelo aprende atrav√©s de tentativa e erro, interagindo com um ambiente para maximizar uma recompensa. √â a t√©cnica por tr√°s de rob√¥s que aprendem a andar ou de sistemas de IA que jogam xadrez.\n\n\n\n1.3.3 Conceitos importantes ao aplicar um modelo de Aprendizado de M√°quina\n\nSobreajuste (Overfitting) e Subajuste (Underfitting): O sobreajuste acontece quando o modelo ‚Äúmemoriza‚Äù os dados de treinamento em vez de aprender a generalizar os padr√µes, falhando em novos dados. O subajuste acontece quando o modelo √© muito simples e n√£o consegue capturar nem mesmo os padr√µes b√°sicos nos dados.\nDados de treino e dados de teste: Para avaliar se o modelo est√° generalizando bem, a base de dados √© dividida. O modelo √© treinado com a maior parte dos dados (dados de treino) e depois √© avaliado em uma por√ß√£o que ele nunca viu antes (dados de teste).\nVi√©s versus vari√¢ncia: O vi√©s √© o erro que o modelo comete por ser muito simples (subajuste). A vari√¢ncia √© o erro do modelo por ser muito complexo e sens√≠vel a pequenas varia√ß√µes nos dados de treinamento (sobreajuste). Encontrar o equil√≠brio entre os dois √© crucial.\nM√©tricas de avalia√ß√£o: S√£o usadas para medir o desempenho do modelo nos dados de teste. Dependendo do problema, podem ser usadas m√©tricas como acur√°cia (a propor√ß√£o de previs√µes corretas), precis√£o e revoca√ß√£o.\n\n\n\n1.3.4 Boas pr√°ticas para a carreira de Ci√™ncia de Dados\nPara quem est√° come√ßando, algumas atitudes podem fazer toda a diferen√ßa no mercado de trabalho:\n\nOlhe os requisitos das vagas: Analise as descri√ß√µes de vagas de ci√™ncia de dados para entender quais s√£o as habilidades mais demandadas, como linguagens de programa√ß√£o (R ou Python), conhecimento de SQL, ferramentas de visualiza√ß√£o e frameworks de machine learning.\nCrie e mantenha um portf√≥lio no GitHub: O GitHub √© essencial para cientistas de dados. Crie um perfil e use-o para mostrar projetos pessoais, c√≥digos e an√°lises. Ter um portf√≥lio demonstra suas habilidades na pr√°tica, muito al√©m do que um curr√≠culo pode dizer.\nMantenha seu LinkedIn atualizado: O LinkedIn √© a principal rede para conex√µes profissionais. Mantenha seu perfil completo, compartilhe seu portf√≥lio, publique artigos ou insights sobre a √°rea e conecte-se com outros profissionais para construir sua rede de contatos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o</span>"
    ]
  },
  {
    "objectID": "01-intro.html#intelig√™ncia-artificial-aprendizado-de-m√°quina-e-aprendizado-profundo",
    "href": "01-intro.html#intelig√™ncia-artificial-aprendizado-de-m√°quina-e-aprendizado-profundo",
    "title": "1¬† Introdu√ß√£o",
    "section": "1.2 Intelig√™ncia Artificial, Aprendizado de M√°quina e Aprendizado Profundo",
    "text": "1.2 Intelig√™ncia Artificial, Aprendizado de M√°quina e Aprendizado Profundo\nEsses termos s√£o frequentemente usados de forma intercambi√°vel, mas t√™m significados distintos. Para sermos mais precisos, cada termo a seguir engloba o pr√≥ximo termo como um subconjunto:\n\nIntelig√™ncia Artificial (IA): O conceito mais amplo. √â a ci√™ncia de criar m√°quinas ou programas que podem simular a intelig√™ncia humana, resolvendo problemas, tomando decis√µes e interagindo com o ambiente.\nAprendizado de M√°quina (Machine Learning - ML): Um subcampo da IA. Trata-se da constru√ß√£o de modelos que aprendem padr√µes a partir de dados, sem serem explicitamente programados para cada tarefa. Em vez de seguir um conjunto de regras fixas, o modelo aprende e se ajusta com base nos exemplos que recebe.\nAprendizado Profundo (Deep Learning - DL): Um subcampo do ML. Utiliza redes neurais artificiais com m√∫ltiplas camadas (por isso o ‚Äúprofundo‚Äù) para analisar dados. √â especialmente eficaz em tarefas complexas, como reconhecimento de imagem e processamento de linguagem natural.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o</span>"
    ]
  }
]