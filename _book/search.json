[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Minicurso: Ciência de Dados com R – Uma Introdução Prática",
    "section": "",
    "text": "Prefácio\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee (KNUTH84?) for additional discussion of literate programming.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html",
    "href": "02-fundamentos.html",
    "title": "2  Fundamentos de R",
    "section": "",
    "text": "2.1 O que são R e RStudio?\nÉ comum que iniciantes confundam R e RStudio, mas esta distinção é crucial para o processo.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#o-que-são-r-e-rstudio",
    "href": "02-fundamentos.html#o-que-são-r-e-rstudio",
    "title": "2  Fundamentos de R",
    "section": "",
    "text": "R é a linguagem de programação e o ambiente de software para computação estatística e gráficos. Pode-se pensar que é o “motor” que executa todos os cálculos, análises e gera os gráficos. Além de tudo, é um projeto de código aberto, gratuito e mantido por uma vasta comunidade de desenvolvedores e estatísticos ao redor do mundo.\nRStudio é um Ambiente de Desenvolvimento Integrado (IDE, do inglês Integrated Development Environment). Se o R é o motor do carro, o RStudio1 é o painel, o volante, e todo o interior que torna a condução do carro uma experiência agradável e gerenciável. O RStudio fornece uma interface gráfica e amigável que organiza o trabalho em R, facilitando a escrita de scripts (arquivos de códigos), a visualização de gráficos, o gerenciamento de pacotes (bibliotecas) e muito mais. Embora seja possível utilizar o R sem o RStudio, a utilização do RStudio é fortemente recomendada, pois deixa o processo de análise muito mais interativo e organizado.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#instalação-passo-a-passo",
    "href": "02-fundamentos.html#instalação-passo-a-passo",
    "title": "2  Fundamentos de R",
    "section": "2.2 Instalação passo a passo",
    "text": "2.2 Instalação passo a passo\nA instalação adequada dos programas é um pré-requisito crucial. A ordem de instalação é importante: R deve ser instalado antes do RStudio.\n\nInstalando o R:\n\n\nAcesse o site do Comprehensive R Archive Network (CRAN)2, que é o repositório oficial para o R e seus pacotes.\nNa página inicial, selecione o link de download para o seu sistema operacional (Linux, macOS ou Windows).\nSiga as instruções para baixar a versão mais recente (“base”). É crucial baixar a versão diretamente do CRAN, pois os gerenciadores de pacotes de alguns sistemas operacionais (como o get-apt do Ubuntu) podem fornecer versões desatualizadas.\nExecute o arquivo de instalação baixado e siga as instruções padrão, aceitando as configurações padrão.\n\n\nInstalando o RStudio:\n\n\nApós a instalação do R, acesse o site da Posit e clique para baixar a versão gratuita do RStudio Desktop.\nBaixe o instalador apropriado para o seu sistema operacional.\nExecute o arquivo de instalação. O RStudio detectará automaticamente a instalação do R existente.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#navegando-na-interface-do-rstudio",
    "href": "02-fundamentos.html#navegando-na-interface-do-rstudio",
    "title": "2  Fundamentos de R",
    "section": "2.3 Navegando na interface do RStudio",
    "text": "2.3 Navegando na interface do RStudio\nAo abrir o RStudio pela primeira vez, a interface se apresenta dividida em quatro painéis ou quadrantes principais, cada um com uma função específica:\n\nEditor de scripts (Superior esquerdo): Este é o seu principal espaço de trabalho. Aqui, você escreverá e salvará seus scripts R (arquivos com extensão .R). Trabalhar em um script, em vez de digitar comandos diretamente no console, é a base da ciência reprodutível, pois permite salvar, comentar e reutilizar seu código.\nConsole (Inferior esquerdo): O console é o código R é efetivamente executado. Você pode digitar os comandos diretamente nele para testes rápidos ou executar linhas de códigos do seu script (utilizando o atalho Ctrl+Enter). A saída dos comandos também aparecerá aqui.\nAmbiente e Histórico (Superior direito): A aba Environment mostra todos os objetos (como datasets, variáveis, etc.) que foram criadas na sessão atual do R. Já a aba History mantém um registro de todos os comandos utilizados.\nArquivos, Gráficos, Pacotes e Ajuda (Inferior direita): Este painel multifuncional permite navegar pelos arquivos do seu computador (Files) , visualizar gráficos gerados (Plots), gerenciar pacotes instalados (Packages), e acessar documentações de ajuda do R (Help).\n\nÉ importante salientar que o RStudio permite customizações, como a alteração das posições dos painéis.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#o-conceito-de-pacotes",
    "href": "02-fundamentos.html#o-conceito-de-pacotes",
    "title": "2  Fundamentos de R",
    "section": "2.4 O conceito de pacotes",
    "text": "2.4 O conceito de pacotes\nA grande força do R reside em seu ecossistema de pacotes. Um pacote é a coleção de funções, dados e documentação que estende as capacidades iniciais do R. Para qualquer tarefa estatística ou de manipulação de dados que se possa imaginar, provavelmente existe algum pacote que a facilita.\n\n2.4.1 Instalando e Carregando Pacotes Essenciais\nExiste uma distinção básica a ser realizada entre instalar e carregar um pacote.\n\nInstalação: É o ato de baixar o pacote do CRAN e instalá-lo no computador. Isso é realizado apenas uma vez para cada pacote.\nCarregamento: É o ato de carregar o pacote instalado em sua sessão do R de forma que as funções adicionais fiquem disponíveis para uso. Isso precisa ser feito toda vez que uma sessão no R é iniciada.\n\nPara este material, os pacotes centrais são: tidyverse, lme4, lmerTest e nlme. Um dos métodos para instalar pacotes R no computador é por meio da função install.packages():\n\n# Instala o pacote tidyverse, que inclui dplyr, ggplot2 e outros\ninstall.packages(\"tidyverse\")\n\n# Instala o pacote para modelos lineares mistos\ninstall.packages(\"lme4\")\n\n# Instala outros pacotes para modelos mistos\ninstall.packages(\"lmerTest\")\ninstall.packages(\"nlme\")\n\nApós a instalação, para usar as funções de um pacote, é preciso carregá-lo com a função library():\n\nlibrary(tidyverse)\n\nCabe ressaltar que, ao longo do uso de diversos pacotes, podem ocorrer conflitos de funções com o mesmo nome. Nesses casos, a solução mais prática é utilizar a notação pacote::funcao para indicar explicitamente ao R de qual biblioteca desejamos chamar a função.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#diretório-de-trabalho-e-projetos-rstudio",
    "href": "02-fundamentos.html#diretório-de-trabalho-e-projetos-rstudio",
    "title": "2  Fundamentos de R",
    "section": "2.5 Diretório de Trabalho e Projetos RStudio",
    "text": "2.5 Diretório de Trabalho e Projetos RStudio\nO diretório de trabalho é a pasta no seu computador onde o R irá procurar por arquivos para ler e onde, também, salvará os arquivos criados (como gráficos, scripts e datasets modificados). É possível identificar o diretório atual através do comando getwd() e, embora também seja possível defini-la manualmente com a função setwd(\"caminho/para/sua/pasta\"), essa prática não é aconselhável, visto que o uso de caminhos de arquivos absolutos torna o código não portável; ou seja, ele não irá funcionar se você mover a pasta do projeto ou tentá-la executá-lo em outro computador.\nA solução moderna e robusta para esse problema é a utilização de Projetos RStudio. Um projeto RStudio (extensão .Rproj) é um arquivo que você cria dentro de uma pasta do seu projeto de pesquisa. Ao abrir um projeto, o RStudio automaticamente define o diretório de trabalho para aquela pasta. Isso garante que todos os caminhos de arquivo do seu código possam ser relativos à raiz do projeto, tornando sua análise totalmente reprodutível e compartilhável de forma eficaz. Outra maneira de criar projetos é através do próprio RStudio, através das seguintes instruções File &gt; New Project &gt; New Directory &gt; New Project e nesta última etapa, você escolherá um nome para o projeto e a pasta de sua pesquisa, finalizando em Create Project. A criação de um projeto para cada análise de pesquisa é uma prática fundamental para a organização e a reprodutibilidade científica.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#r-básico",
    "href": "02-fundamentos.html#r-básico",
    "title": "2  Fundamentos de R",
    "section": "2.6 R Básico",
    "text": "2.6 R Básico\nA leitura desta sessão é aconselhada para o leitor que nunca teve contato com o R. Os tópicos introduzidos são especiais para a compreensão do que é um dataframe, a estrutura dos datasets dentro do R, e quais operações estarão sendo realizadas quando estivermos efetuando filtragens e modificações de suas colunas. Também são importantes para a compreensão do que é uma função no R.\n\n2.6.1 Operadores Matemáticos\nOs operadores matemáticos, também conhecidos por operadores binários, dentro do ambiente R soam como familiares. A Tabela 2.1 exibe os operadores mais básicos utilizados.\nPara exemplificar como efetuar cálculos de expressões matemáticas no R, suponha que desenhamos calcular o valor de: \\[2\\times 2 + \\frac{4 + 4}{2}.\\] Para isso, escrevemos 2*2 + (4+4)/2 no console para determinarmos o resultado\n\n2*2 + (4+4)/2\n\n[1] 8\n\n\n\n\n\n\nTabela 2.1: Operadores matemáticos básicos.\n\n\n\n\n\n\nOperadores\nDescrição\n\n\n\n\n+\nAdição\n\n\n-\nSubtração\n\n\n*\nMultiplicação\n\n\n/\nDivisão\n\n\n^\nExponenciação\n\n\n\n\n\n\n\n\n\n\n\n\n2.6.2 Objetos e funções\nO R permite guardar valores dentro de um objeto. Um objeto é simplesmente um nome que guarda uma determinada informação na memória do computador, que é criado por meio do operador &lt;-. Veja que no código a seguir\n\nx &lt;- 10 # Salvando \"10\" em \"x\"\nx       # Avaliando o objeto \"x\"\n\n[1] 10\n\n\nfoi salvo que a informação que x carrega é o valor 10. Portanto, toda vez que o objeto x for avaliado, o R irá devolver o valor 10.\nÉ importante ressaltar que há regras para a nomeação dos objetos, dentre elas, não começar com números. Assim, todos os seguintes exemplos são permitidos: x &lt;- 1, x1 &lt;- 1, meu_objeto &lt;- 1, meu.objeto &lt;- 1. Ainda, o R diferencia letras minúsculas de maiúsculas, então objetos como y e Y são diferentes.\nEnquanto que os objetos são nomes que salvam informações de valores, funções são nomes que guardam informações de um código R, retornando algum resultado programado. A sintaxe básica de uma função é nome_funcao(arg1, arg2, ...). Os valores dentro dos parênteses são chamados por argumentos, que são informações necessárias para o bom funcionamento de uma função. Às vezes, uma função não necessita do fornecimento de argumentos específicos.\nUma função simples, porém útil, é a sum(). Ela consiste em somar os valores passados em seu argumento. Suponha que desejamos somar 1+2+3+4+5. Assim,\n\nsum(1,2,3,4,5)\n\n[1] 15\n\n\né possível reparar que o resultado é 15.\nA classe de um objeto é muito importante na programação em R. É a partir disso que as funções e operadores conseguem entender o que fazer com cada objeto. Há uma infinidade de classes, dentre as mais conhecidas são: numeric, character, data.frame, logical e factor. Para averiguar o tipo de classe, a função class() retorna exatamente a classe do objeto.\n\nclass(\"a\")\n\n[1] \"character\"\n\nclass(1)\n\n[1] \"numeric\"\n\nclass(mtcars)\n\n[1] \"data.frame\"\n\nclass(TRUE)\n\n[1] \"logical\"\n\n\n\n\n2.6.3 Importanto dados\nUma atividade importante para qualquer análise estatística que vier ser feita no R é importante importar os dados para o ambiente de trabalho, que ficarão guardados dentro de um objeto no projeto RStudio – afinal, como faríamos as análises sem os dados? No contexto da Biologia, isso costuma significar ler arquivos com medidas de peso, contagens de indivíduos, medidas de comprimento etc., geralmente armazenados em formatos de texto (.csv ou .tsv) ou planilhas (.xlsx). As principais funções para cada ocasião de arquivo são:\n\nCSV com cabeçalho:\n\n\ndados &lt;- read.csv(\"dados.csv\",\n  header = TRUE, # indica que há cabeçalho\n  sep    = \",\",  # separador vírgula\n  stringsAsFactors = FALSE # evita conversão automática em fatores\n)\n\n\nTXT ou TSV com tabulação:\n\n\ndados &lt;- read.delim(\"dadostsv\", \n  header = TRUE, \n  sep    = \"\\t\"\n)\n\n\nPlanilhas no Excel (arquivos .xlsx):\n\n\ndados &lt;- readxl::read_excel(\"dados.xlsx\",\n  sheet = \"Planilha1\" # aqui você escolhe a planilha a ser lida\n)\n\nRessaltamos, neste caso, a necessidade da utilização da biblioteca readxl para que seja possível lermos planilhas no R.\n\n\n2.6.4 Vetores e Data frames\nVetores são uma estrutura fundamental dentro do R, em especial, é a partir deles que os data frames são construídos. Por definição, são conjuntos indexados de valores e para criá-los, basta utilizar a função c() com valores separados por vírgula (ex.: c(1,2,4,10)). Para acessar um valor dentro de um determinado vetor, utiliza-se os colchetes []:\n\nvetor &lt;- c(\"a\", \"b\", \"c\")\n\n# Acessando valor \"b\"\nvetor[2]\n\n[1] \"b\"\n\n\nUm vetor só pode guardar um tipo de objeto e ele terá sempre a mesma classe dos objetos que guarda. Caso tentarmos misturar duas classes, o R vai apresentar o comportamento conhecido como coerção.\n\nclass(c(1,2,3))\n\n[1] \"numeric\"\n\nclass(vetor)\n\n[1] \"character\"\n\nclass(c(1,2,\"a\",\"b\"))\n\n[1] \"character\"\n\n\nNeste caso, todos os elementos do vetor se transformaram em texto.\nAssim, também, data frames são de extrema importância no R, visto que são os objetos que guardam os dados e são equivalentes a uma planilha do Excel. A principal característica é possuir linha e colunas. Em geral, as colunas são vetores de mesmo tamanho (ou dimensão). Um valor específico de um data frame pode ser acessado, também, via colchetes []:\n\nclass(mtcars)\n\n[1] \"data.frame\"\n\nmtcars[1,2]\n\n[1] 6\n\n\nmtcars é um conjunto de dados muito conhecido na comunidade R.\n\n\n2.6.5 Fatores\nFatores são uma classe de objetos no R criada para representar variáveis categóricas numericamente. A característica que define essa classe é o atributo levels, que representam as possíveis categorias de uma variável categórica.\nA título de exemplificação, considere o objeto sexo que contém as informações do sexo de uma pessoa. As possibilidades são: F (feminino) e M (masculino). Por padrão, o R interpreta essa variável como texto (character), no entanto, é possível transformá-la em fator por meio da função as.factor().\n\nsexo &lt;- c(\"F\", \"F\", \"M\", \"M\", \"F\")\nclass(sexo)\n\n[1] \"character\"\n\n# Transformando em fator\nclass(as.factor(sexo))\n\n[1] \"factor\"\n\nas.factor(sexo)\n\n[1] F F M M F\nLevels: F M\n\n\nObserva-se que a linha adicional Levels: F M indicam as categorias. Por padrão, o R ordena esses níveis em ordem alfabética. Para facilitar os cálculos e análises, o R interpreta os níveis categóricos como sendo números distintos, sendo assim, dentro do nosso exemplo F representaria o número 0 e M representaria o 1.\n\n\n2.6.6 Valores especiais\nValores como NA, NaN, Inf e NULL ocorrem frequentemente dentro do mundo da programação estatística no R. Em resumo:\n\nNA representa a Ausência de Informação. Suponha que o vetor idades que representa a idade de três pessoas. Uma situação que pode ocorrer é idades &lt;- c(10, NA, NA). Portanto, não é sabido a idade das pessoas 2 e 3.\nNaN representa indefinições matemáticas. Um exemplo típico é o valor \\(\\log{-1}\\), do qual \\(x = -1\\) não pertence aos possíveis valores de saída da função logarítmica, gerando um NaN (Not a number).\n\n\nlog(-1)\n\nWarning in log(-1): NaNs produzidos\n\n\n[1] NaN\n\n\n\nInf representa um número muito grande ou um limite matemático. Exemplos:\n\n\n# Número muito grande\n10^510\n\n[1] Inf\n\n# Limite matemático\n1/0\n\n[1] Inf\n\n\n\nNULL representa a ausência de um objeto. Muitas vezes define-se um objeto como nulo para dizer ao R que não desejamos atribuir valores a ele.\n\n\n\n2.6.7 Pedindo ajuda\nUma das coisas que intimidam novos programadores, independente da linguagem utilizada, é a ocorrência de erros. Neste sentido, o R pode ser um grande aliado, pois ele relata mensagens, erros e avisos sobre o código no console, como se fosse uma espécie de resposta e/ou comunicação. As situações são:\n\nError: em situações de erro legítimo aparecerá mensagens do tipo Error in ... e tentará explicar o que há de errado. Nestas situações o código, geralmente, não é executado. Por exemplo: Error in ggplot(...) : could not find function \"ggplot\".\nWarning: em situações de avisos, o R exibirá uma mensagem do tipo Warning: ... e tentará explicar o motivo do aviso. Geralmente, o código será executado, mas com algumas ressalvas. Por exemplo: Warning: Removed 2 rows containing missing values (geom_point).\nMessage: quando o texto exibido não se enquadra nas duas opções anteriores, dizemos que é apenas uma mensagem. Pense, nessa situação, que tudo está acontecendo como o esperado e está tudo bem.\n\nQuando surgir qualquer uma dessas saídas, não estaremos perdidos, pois o R oferece mecanismos para encontrarmos respostas. Afinal, nem todo mundo decorou todas as funções ou argumentos. Os principais mecanismos são:\n\n?função ou help(função) para consultar a documentação oficial.\n??termo e help.search(\"termo\") para buscas por palavras-chave.\n\nAlém disso, o RStudio oferece alguns Cheatsheets (resumo de códigos) que podem ajudar com determinados pacotes. E, por fim, existem grandes comunidade online, tais como: Stack Overflow e RStudio Community dos quais também podem serem úteis.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "02-fundamentos.html#footnotes",
    "href": "02-fundamentos.html#footnotes",
    "title": "2  Fundamentos de R",
    "section": "",
    "text": "Existem outras IDEs que podem ser utilizadas no lugar do RStudio, como o Visual Studio Code. No entanto, focaremos nosso estudo utilizando o RStudio.↩︎\nUm outro repositório conhecido na comunidade científica para pacotes com o intuítuo de modelagem na biologia, em especial na genética, é o Bioconductor.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fundamentos de R</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html",
    "href": "03-tidyverse.html",
    "title": "3  Tidyverse",
    "section": "",
    "text": "3.1 Manipulação de dados com o pacote dplyr\nO tidyverse (WICKHAM ET AL., 2019) é um ecossistema de pacotes R que reúne as tarefas essenciais de qualquer fluxo de trabalho em ciência de dados: importação, organização, manipulação, visualização e programação. Seu principal objetivo é criar uma sintaxe consistente e legível, facilitando a comunicação entre quem escreve o código e quem o executa. Note-se que, embora o tidyverse cubra grande parte do fluxo de trabalho, ele não inclui ferramentas específicas de modelagem estatística.\nPara facilitar essa integração, o tidyverse utiliza intensamente do operador pipe1 (%&gt;%) , que passa o resultado de uma etapa diretamente para a próxima, evitando aninhamentos confusos. Ao carregar o pacote, diversos módulos são automaticamente disponibilizados:\nEntre os principais estão:\nComo dito, muitos pacotes definem funções com nomes idênticos, sendo costatumum que o console exiba nomes como:\nUm pilar do tidyverse é a adoção do princípio tidy (WICKHAM, 2014), em que:\nNesse contexto, a entidade observacional é o conceito central que define o que uma linha representa. Pode ser um paciente em um estudo clínico, um país em dados econômicos ou, como nos exemplos a seguir:\nA estrutura de dados que implementa essa filosofia no tidyverse é o tibble. Ele é a versão moderna do data.frame, projetado para ser mais prático e informativo, exibindo resumos concisos dos dados e fornecendo diagnósticos mais úteis.\nUma vez apresentada a filosofia e a estrutura de dados do tidyverse, o foco se volta para a aplicação prática. A seguir, a concentração do material residirá nos dois pacotes centrais do tidyverse: o dplyr, para manipulação de dados, e o ggplot2, para a criação de gráficos.\nO dplyr é um pacote do tidyverse que fornece um conjunto de ferramentas robustas e intuitivas para manipulação de dados. Os comandos oferecidos soam um tanto quanto intuitivos, correspondendo ações comuns na área de análise de dados. Para explorar as principais funções será utilizado o dataset penguins, focando em processos de filtragem, organização, transformação e resumos dos dados, permitindo responder a perguntas básicas sobre a biologia e ecologia dos pinguins.\nO primeiro passo a ser feito é instalar a biblioteca palmerpenguins e, em seguida, carregá-la no ambiente de trabalho, para que possamos realizar uma inspeção inicial na estrutura dos dados.\ninstall.packages(\"palmerpenguins\") # Realizar apenas uma única vez\nlibrary(palmerpenguins)\nPara carregarmos os dados sobre pinguins no ambiente de trabalho, podemos utilizar a função data():\ndata(\"penguins\", package = \"palmerpenguins\")\nPodemos observar que no painel Environment do RStudio, aparece o objeto penguins, isso significa que o conjunto de dados está carregado no ambiente de trabalho e podemos dar início nas inspeções. O primeiro comando que será visto é o glimpse(). Ele exibe, de maneira prática e rápida, a estrutura do dataset como: dimensão (número de linhas e colunas), o nome de cada coluna, o tipo de dado de cada coluna e as primeiras observações.\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\nA saída deste comando revela que existem 344 observações e 8 variáveis, sendo elas species, island, bill_length_mm, flipper_length_mm, body_mass_g, sex e year, com seus respectivos tipos, como factor para species e numeric para bill_length_mm. Além disso, é possível observar dados ausentes em algumas variáveis, representados por NA. Em geral, nos datasets disponíveis em pacotes R, é possível utilizar o comando help(penguins) para buscar informações sobre o conjunto de dados que será trabalhado.\nExecutando o comando de ajuda, são obtidas as seguintes informações sobre as variáveis:\nAdicionalmente, também é informado que os dados foram originalmente publicados no estudo de Gorman et al. (2014) e que essa pesquisa fez parte do programa Palmer Station Long-Term Ecological Research (LTER). Isso significa que o conjunto de dados que está sendo utilizado possui uma origem científica real, ligada a questões sobre como o ambiente e as diferenças entre sexos afetam a vida dessas aves.\nA segunda função que será vista é o select(). Frequentemente, um conjunto de dados contém mais informações do que o necessário para uma análise específica. Com isso em mente, a função select() permite-nos selecionar colunas de interesse. Em geral, os argumentos são os nomes das colunas.\npenguins %&gt;% \n  select(species, island, sex)\n\n# A tibble: 344 × 3\n   species island    sex   \n   &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt; \n 1 Adelie  Torgersen male  \n 2 Adelie  Torgersen female\n 3 Adelie  Torgersen female\n 4 Adelie  Torgersen &lt;NA&gt;  \n 5 Adelie  Torgersen female\n 6 Adelie  Torgersen male  \n 7 Adelie  Torgersen female\n 8 Adelie  Torgersen male  \n 9 Adelie  Torgersen &lt;NA&gt;  \n10 Adelie  Torgersen &lt;NA&gt;  \n# ℹ 334 more rows\nO dplyr também oferece “seletores auxiliares” que tornam a seleção mais poderosa e flexível. Por exemplo, caso desejarmos selecionar todas as medidas biométricas contidas no dataset que terminam com _mm, é possível usar a função-argumento ends_with() dentro de select():\npenguins %&gt;% \n  select(\n    body_mass_g, ends_with(\"_mm\")\n  )\n\n# A tibble: 344 × 4\n   body_mass_g bill_length_mm bill_depth_mm flipper_length_mm\n         &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n 1        3750           39.1          18.7               181\n 2        3800           39.5          17.4               186\n 3        3250           40.3          18                 195\n 4          NA           NA            NA                  NA\n 5        3450           36.7          19.3               193\n 6        3650           39.3          20.6               190\n 7        3625           38.9          17.8               181\n 8        4675           39.2          19.6               195\n 9        3475           34.1          18.1               193\n10        4250           42            20.2               190\n# ℹ 334 more rows\nOutros seletores úteis incluem starts_with() e contains(). Para remover colunas, utiliza-se o sinal de menos (-). Por exemplo, deseja-se remover as colunas ano e island:\npenguins %&gt;% \n  select(-year, -island)\n\n# A tibble: 344 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt; \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            NA            NA                  NA          NA &lt;NA&gt;  \n 5 Adelie            36.7          19.3               193        3450 female\n 6 Adelie            39.3          20.6               190        3650 male  \n 7 Adelie            38.9          17.8               181        3625 female\n 8 Adelie            39.2          19.6               195        4675 male  \n 9 Adelie            34.1          18.1               193        3475 &lt;NA&gt;  \n10 Adelie            42            20.2               190        4250 &lt;NA&gt;  \n# ℹ 334 more rows\nAntes prosseguirmos para a próxima função, vale destacar que o conjunto de dados penguins é um objeto tibble dentro do R e, portanto, por mais que existam 344 observações, o tibble enxuga a visualização para somente 10, além de indicar quantas linhas ainda existem.\nA terceira função é o filter(). Enquanto select() trabalha nas colunas, o filter() trabalha nas linhas, permitindo-nos manter apenas as observações que satisfazem certas condições. É aqui que é possível responder perguntas investigadas com relação aos dados. Por exemplo, para encontrar todos os pinguins da espécie Adelie que vivem na ilha Torgersen:\npenguins %&gt;% \n  filter(\n      species == \"Adelie\", island == \"Torgersen\"\n    )\n\n# A tibble: 52 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 42 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nNeste exemplo, as condições separadas por vírgula são unidas por um “E” lógico. Também é possível utilizar o “OU” lógico para determinar pinguins mais pesados (acima de 6000g) ou com bicos muito longos (mais de 55mm) através do conectivo |:\npenguins %&gt;% \n  filter(\n    body_mass_g &gt; 6000 | bill_length_mm &gt; 55\n  )\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Gentoo    Biscoe           49.2          15.2               221        6300\n2 Gentoo    Biscoe           59.6          17                 230        6050\n3 Gentoo    Biscoe           55.9          17                 228        5600\n4 Gentoo    Biscoe           55.1          16                 230        5850\n5 Chinstrap Dream            58            17.8               181        3700\n6 Chinstrap Dream            55.8          19.8               207        4000\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nO filter() também permite encontrar valores ausentes (NAs) em conjunto da função is.na(). Por exemplo, deseja-se verificar quais pinguins não tiveram seu sexo registrado:\npenguins %&gt;% \n  filter(is.na(sex))\n\n# A tibble: 11 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           NA            NA                  NA          NA\n 2 Adelie  Torgersen           34.1          18.1               193        3475\n 3 Adelie  Torgersen           42            20.2               190        4250\n 4 Adelie  Torgersen           37.8          17.1               186        3300\n 5 Adelie  Torgersen           37.8          17.3               180        3700\n 6 Adelie  Dream               37.5          18.9               179        2975\n 7 Gentoo  Biscoe              44.5          14.3               216        4100\n 8 Gentoo  Biscoe              46.2          14.4               214        4650\n 9 Gentoo  Biscoe              47.3          13.8               216        4725\n10 Gentoo  Biscoe              44.5          15.7               217        4875\n11 Gentoo  Biscoe              NA            NA                  NA          NA\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nA interpretação do NA é relativa ao contexto dos dados. No caso das observações sobre os pinguins, os valores ausentes na variável sex permite identificar pinguins que não tiveram o sexo avaliado, tornando um provável erro frustrante de coleta de dados para um objeto de investigação. O pacote tidyr, também do tidyverse, oferece a função drop_na(), que remove quaisquer linhas que contenham NAs, permitindo a criação de um dataset auxiliar:\npenguins_completos &lt;- penguins %&gt;% \n  drop_na()\nA quarta função que será apresentada é arrange(), que permite reordenar as linhas do dataframe com base nos valores de uma ou mais colunas. Isso é útil para encontrar extremos ou simplesmente para organizar a saída de uma forma mais lógica. Para encontrar os pinguins mais leves, ordenamos pela massa corporal em ordem crescente (o padrão):\npenguins %&gt;% \n  arrange(body_mass_g)\n\n# A tibble: 344 × 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Chinstrap Dream              46.9          16.6               192        2700\n 2 Adelie    Biscoe             36.5          16.6               181        2850\n 3 Adelie    Biscoe             36.4          17.1               184        2850\n 4 Adelie    Biscoe             34.5          18.1               187        2900\n 5 Adelie    Dream              33.1          16.1               178        2900\n 6 Adelie    Torgers…           38.6          17                 188        2900\n 7 Chinstrap Dream              43.2          16.6               187        2900\n 8 Adelie    Biscoe             37.9          18.6               193        2925\n 9 Adelie    Dream              37.5          18.9               179        2975\n10 Adelie    Dream              37            16.9               185        3000\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nPara ordenar os valores em ordem decrescente (do maior para o menor), utilizamos a função auxiliar desc(), desta maneira, encontramos os pinguins mais pesados:\npenguins %&gt;% \n  arrange(desc(body_mass_g))\n\n# A tibble: 344 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo  Biscoe           49.2          15.2               221        6300\n 2 Gentoo  Biscoe           59.6          17                 230        6050\n 3 Gentoo  Biscoe           51.1          16.3               220        6000\n 4 Gentoo  Biscoe           48.8          16.2               222        6000\n 5 Gentoo  Biscoe           45.2          16.4               223        5950\n 6 Gentoo  Biscoe           49.8          15.9               229        5950\n 7 Gentoo  Biscoe           48.4          14.6               213        5850\n 8 Gentoo  Biscoe           49.3          15.7               217        5850\n 9 Gentoo  Biscoe           55.1          16                 230        5850\n10 Gentoo  Biscoe           49.5          16.2               229        5800\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nTambém é possível ordenar múltiplas colunas. Por exemplo, para encontrar o pinguim mais pesado dentro de cada espécie:\npenguins %&gt;% \n  arrange(\n    species, # Primeiro por espécie\n    desc(body_mass_g) # Depois por massa decrescente\n  )\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Biscoe              43.2          19                 197        4775\n 2 Adelie  Biscoe              41            20                 203        4725\n 3 Adelie  Torgersen           42.9          17.6               196        4700\n 4 Adelie  Torgersen           39.2          19.6               195        4675\n 5 Adelie  Dream               39.8          19.1               184        4650\n 6 Adelie  Dream               39.6          18.8               190        4600\n 7 Adelie  Biscoe              45.6          20.3               191        4600\n 8 Adelie  Torgersen           42.5          20.7               197        4500\n 9 Adelie  Dream               37.5          18.5               199        4475\n10 Adelie  Torgersen           41.8          19.4               198        4450\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\nA quinta função e, com certeza, uma das mais funcionais é a mutate(). Ela permite criar novas colunas (variáveis) que são funções de colunas já existentes, sem modificar as originais. Por exemplo, suponha que desejamos mostrar somente as espécies e massas de pinguins em quilogramas (kg):\npenguins %&gt;% \n  mutate(body_mass_kg = body_mass_g/1000) %&gt;% \n  select(species, body_mass_kg)\n\n# A tibble: 344 × 2\n   species body_mass_kg\n   &lt;fct&gt;          &lt;dbl&gt;\n 1 Adelie          3.75\n 2 Adelie          3.8 \n 3 Adelie          3.25\n 4 Adelie         NA   \n 5 Adelie          3.45\n 6 Adelie          3.65\n 7 Adelie          3.62\n 8 Adelie          4.68\n 9 Adelie          3.48\n10 Adelie          4.25\n# ℹ 334 more rows\nPodemos usar mutate() para criar categorias. A função case_when() é extremamente útil para criar classificações baseadas em condições lógicas., Suponha que desejamos criar uma categoria de tamanho baseada na massa corporal:\npenguins %&gt;% \n  mutate(\n    size_category = case_when(\n      body_mass_g &gt; 4750 ~ \"Grande\",\n      body_mass_g &lt; 3500 ~ \"Pequeno\",\n      TRUE ~ \"Médio\"\n    )\n  ) %&gt;% \n  select(\n    species, body_mass_g, size_category\n  )\n\n# A tibble: 344 × 3\n   species body_mass_g size_category\n   &lt;fct&gt;         &lt;int&gt; &lt;chr&gt;        \n 1 Adelie         3750 Médio        \n 2 Adelie         3800 Médio        \n 3 Adelie         3250 Pequeno      \n 4 Adelie           NA Médio        \n 5 Adelie         3450 Pequeno      \n 6 Adelie         3650 Médio        \n 7 Adelie         3625 Médio        \n 8 Adelie         4675 Médio        \n 9 Adelie         3475 Pequeno      \n10 Adelie         4250 Médio        \n# ℹ 334 more rows\nAs funções group_by() e summarise() formam uma dupla formidável para agrupar e resumir os dados, pertencendo ao coração da análise de dados. A função summarise() erve para calcular estatísticas resumidas (como média, total, mínimo etc.) e, quando usada em conjunto com group_by() permite gerar resumos por grupo.\nInicialmente, vamos utilizar o summarise() no dataset completo para obter estatísticas globais. Não obstante, é bom frisar a utilização do argumento na.rm = TRUE para instruir a remoção dos valores NA.\npenguins %&gt;% \n  summarise(\n    massa_media = mean(body_mass_g, na.rm = TRUE),\n    nadadeira_max = max(flipper_length_mm, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  massa_media nadadeira_max\n        &lt;dbl&gt;         &lt;int&gt;\n1       4202.           231\nNo entanto, essas métricas não fornecem informações com relação as espécies de pinguins. Para resolver isso e possibilitar que mais perguntas sejam respondidas, a função group_by() permite que o R faça operações em subconjuntos. Por exemplo, suponha que desejamos determinar qual é a massa corporal por espécie:\npenguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(\n    massa_media_g = mean(body_mass_g, na.rm = TRUE)\n  )\n\n# A tibble: 3 × 2\n  species   massa_media_g\n  &lt;fct&gt;             &lt;dbl&gt;\n1 Adelie            3701.\n2 Chinstrap         3733.\n3 Gentoo            5076.\nPodemos fazer agrupamentos por múltiplas variáveis para investigações mais profundas. Por exemplo, considere que um pesquisador deseja explorar o dimorfismo sexual. Para isso, estatísticas por espécie e sexo serão calculadas.\ntabela_resumo &lt;- penguins %&gt;% \n  drop_na(sex) %&gt;% \n  group_by(species, sex) %&gt;% \n  summarise(\n    contagem = n(),\n    massa_media_g = mean(body_mass_g),\n    massa_dp_g = sd(body_mass_g),\n    comp_bico_medio_mm = mean(bill_length_mm),\n    .groups = \"drop\"\n  )\ntabela_resumo\nTabela 3.1: Estatísticas descritivas de características biométricas de pinguins, agrupadas por espécie e sexo.\nVale reforçar que a Tabela 3.1 foi gerada usando o dplyr, com as funções auxiliares n() para realizar a contagem de observações em cada grupo e drop_na(sex) para remover as observações onde o sexo é desconhecido, permitindo avaliar dimorfismo sexual em todas as três espécies, especialmente na massa corporal. O grande potencial dessa tabela é obter respostas como:\nEsses resultados permitem tirar conclusões sobre algumas hipóteses biológicas.\nPor fim, a última função que será abordada é a recode(). Muitas vezes, os nomes das categorias nos conjuntos de dados não são ideais para a análise ou apresentação em gráficos. Podem ser longos demais, estarem em outro idioma ou simplesmente não serem claros. Para isso, a função recode() permite renomear valores de uma variável categórica de forma simples e direta. Por exemplo, suponha que desejamos traduzir os termos da variável sex da Tabela 3.1 para o português:\ntabela_resumo %&gt;% \n  mutate(\n    sex = recode(sex,\n                 \"female\" = \"Fêmea\",\n                 \"male\" = \"Macho\")\n  )\nTabela 3.2: Tradução da variável sexo da Tabela 3.1.\nAs principais funções do pacote dplyr que foram vistas estão resumidas e descritas na Tabela Tabela 3.3 e agora que aprendemos como manipular os dados com o dplyr, podemos avançar para a construção de gráficos com o pacote ggplot2.\nTabela 3.3: Descrição das principais funções do tidyverse.\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nglimpse()\nInspecionar conjuntos de dados.\n\n\nselect()\nSeleciona colunas pelo nome.\n\n\nfilter()\nFiltra linhas com base em seus valores.\n\n\narrange()\nReordena as linhas.\n\n\nmutate()\nCria novas colunas (variáveis).\n\n\ngroup_by()\nAgrupa os dados por uma ou mais variáveis.\n\n\nsummarise()\nReduz múltiplos valores a um único resumo.\n\n\nrecode()\nRenomeia categorias de variáveis.\n\n\nn()\nConta o número de observações.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html#manipulação-de-dados-com-o-pacote-dplyr",
    "href": "03-tidyverse.html#manipulação-de-dados-com-o-pacote-dplyr",
    "title": "3  Tidyverse",
    "section": "",
    "text": "species: um fator que denota a espécie do pinguim (Adélie, Chinstrap ou Gentoo).\nisland: um fator que denota ilhas no Arquipélago Palmer na Antártica (Biscoe, Dream ou Torgersen).\nbill_length_mm: um número que representa o comprimento do bico (em milímetros).\nbill_depth_mm: um número que representa a profundidade do bico (em milímetros).\nflipper_length_mm: um número que representa o comprimento da nadadeira (em milímetros).\nbody_mass_g: um número inteiro que representa a massa do animal (em gramas).\nsex: um fator que representa o sexo do animal (feminino ou masculino).\nyear: um número inteiro que denota o ano de estudo (2007, 2008 ou 2009).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOs pinguins Gentoo são, em média, os mais pesados.\nDentro de cada espécie, os machos são consistentemente mais pesados e têm bicos mais longo que as fêmeas.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html#visualização-de-dados-com-ggplot2",
    "href": "03-tidyverse.html#visualização-de-dados-com-ggplot2",
    "title": "3  Tidyverse",
    "section": "3.2 Visualização de Dados com ggplot2",
    "text": "3.2 Visualização de Dados com ggplot2\nSe o dplyr é a gramática da manipulação de dados, possuindo funções essenciais para esse trabalho, o ggplot2 (WICKHAM, 2016) é gramática dos gráficos, permitindo construir gráficos por meio de camadas e oferecendo um sistema robusto e flexível para visualização os dados. Nesta seção, continuaremos utilizando os dados dos pinguins para explorar alguns insights visuais, desde gráficos mais simples até os mais elaborados.\nTodo gráfico no ggplot2 é constituído por três camadas essenciais:\n\nDados (data): O dataframe que contém as informações a serem plotadas.\nMapeamento Estéticos (aes): A função aes() (de aesthetics) descreve como as variáveis do nosso dataframe são mapeadas para as propriedades visuais do gráfico. As estéticas mais comuns são x e y (os eixos), mas também incluem color (cor), shape (forma), size (tamanho) e alpha (transparência/opacidade).\nObjetos geométricos (geom): Os geoms definem como os dados são representados visualmente. Por exemplo, geom_point() cria um gráfico de dispersão, geom_bar() cria um gráfico de barras, geom_line() cria um gráfico de linhas, e assim por diante.\n\n\n3.2.1 Estatística descritiva\nAntes de explorar as relações gráficas, é útil enfatizar e entender alguns conceitos essenciais da Estatística Descritiva como os tipos de variáveis, normas para tabelas e as definições de frequências.\n\nEm geral, pode-se dizer que existem duas categorias de variáveis dentro da estatística:\n\nVariáveis Qualitativas: Também chamadas por variáveis categóricas e como o próprio nome diz, expressam qualidade e indicam categoria ou classificação a qual o objeto pertence. Se existir uma ordem entre as possíveis categorias, a variável é dita qualitativa ordinal. Caso contrário, é dita ser qualitativa nominal.\nVariáveis Quantitativas: São variáveis que tomam valores numéricos e expressam quantidade. Podem ser especificadas por Variáveis Discretas, quando assumem valores dentro de um conjunto enumerável (quando é possível contá-las) ou por Variáveis Continuas, quando podem assumir infinitos valores de um intervalo não inumerável2 (não é possível contar o número de valores dentro de um intervalo).\n\nAssim, para explorar e apresentar as informações contidas num conjunto de dados, precisamos resumir essas informações de forma que seja possível enxergá-las rapidamente e adquirir conhecimento sobre o assunto.\nO resumo pode ser feito por meio de tabelas, gráficos e cálculo de algumas quantidades representativas. O primeiro passo é identificar o tipo de cada variável para aplicarmos a técnica apropriada.\nNo entanto, antes de explorarmos a organização dos dados em tabelas e gráficos, são necessários conceitos sobre algumas métricas essenciais denominadas por medidas resumo. Elas oferecem uma forma numérica e concisa de descrever as principais características das variáveis que serão trabalhadas. Em geral, são divididas em duas categorias essenciais: as medidas de tendência central, que informam onde o “centro” dos dados se localiza (como a média, mediana e moda), e as medidas de dispersão, que quantificam o quão espalhados os dados estão (como a amplitude, o desvio padrão e a variância).\nA média aritmética é definida como sendo a soma de todos os valores dividida pelo número de observações ou indivíduos, ou seja, denotando-se as \\(n\\) observações de uma variável \\(X\\) por \\(x_1, x_2, \\dots, x_n\\) e a média por \\(\\bar{x}\\) temos: \\[\\bar{x} = \\frac{1}{n}\\sum_{i = 1}^{n} x_i\\] As principais propriedades da média são:\n\nÉ uma medidas simples e popular;\nÉ sensível aos valores e discrepantes ou extremos. Portanto, na presença destes, a média pode não ser uma representação de valores típicos;\nÉ o ponto de equilíbrio da distribuição;\nPara \\(k\\) constante e \\(X\\) variável, têm-se que a média de \\((X + k)\\) é \\((\\bar{x} + k)\\) e, também, a média de \\((kX)\\) é \\((k\\bar{x})\\).\nPara \\(X\\) e \\(Y\\) variáveis independentes, a média de \\((X\\pm Y)\\) é \\((\\bar{x} \\pm \\bar{y})\\).\n\nA mediana é o valor do meio de uma distribuição, ou seja, num histograma, é o valor que deixa exatamente 50% dos dados de cada lado. Para determinar o valor exato da mediana é necessário ordenar todos os valores, do menor para o maior. Se \\(n\\), o número de observações, é ímpar então a mediana é o valor que fica exatamente no centro; se \\(n\\) é par, então é a média dos dois valores centrais.\nAs principais propriedades da mediana são:\n\nNão é sensível a valores discrepantes e, portanto, é a mais apropriada para representar valores típicos quando a distribuição é assimétrica;\nNão apresenta as propriedades matemáticas convenientes que a média possui.\n\nQuando a distribuição é simétrica, média e mediana são iguais. No entanto, caso contrário, a média estará mais afastada do meio que a mediana no sentido de uma cauda mais longa.\nA moda é simplesmente o valor mais frequente da variável de estudo e para distribuições simétricas, média, mediana e moda possuem valores iguais.\nUma vez reconhecido o centro da distribuição, é necessário ter uma ideia do quanto os valores estão distantes deste centro. Quanto mais heterogêneo forem os dados, maior a dispersão e vice-versa. Dentre as métricas que dão essa ideia, destacam-se:\nA amplitude definida pela diferença entre o maior e o menor valor. Além disso, é sensível a valores extremos. O primeiro quartil (\\(q_1\\)) e terceiro quartil (\\(q_3\\)), que dividem, respectivamente, o conjunto de dados em 25% e 75%. É válido ressaltar que todo conjunto de dados apresentam 3 quartis, dividindo o conjunto ordenado em quatro partes iguais, além disso, o segundo quartil (\\(q_2\\)) é igual a mediana. Essas medidas são úteis na construção do gráfico de caixa (boxplot) que será visto em sequência.\nO desvio padrão (\\(s\\)) é a medida de dispersão mais popular e mede a dispersão de todos os valores em relação à média. Para calculá-lo, primeiramente calcula-se a variância, denotada por \\(s^2\\), que é definida por: \\[s^2 = \\mathbb{V}(X) = \\frac{1}{n-1}\\sum_{i = 1}^{n}(x_i - \\bar{x})^2 = \\frac{1}{n-1}\\left(\\sum_{i = 1}^{n}x_i^2 - \\frac{\\left(\\sum_{i = 1}^{n} x_i\\right)^2}{n}\\right)\\] a diferença \\((x_i - \\bar{x})\\) é chamada de desvio, representando o quanto o indivíduo \\(i\\) desviou da média geral. A variância representa a média dos quadrados dos desvios em relação à média. Além disso, observe que a unidade de medida da variância é a unidade da variável \\(x\\) ao quadrado, dificultando sua interpretação e, para lidar com isso, utiliza-se o desvio-padrão, visto que é seu valor está na mesma escala de medida das observações, em que valores altos indica que os dados estão bastante dispersos e valores baixos, os indivíduos estão próximos da média, mostrando uma homogeneidade nos dados. As principais propriedades da variância (ou do desvio padrão) são:\n\nPara \\(k\\) constante, \\(\\mathbb{V}(k) = 0\\), \\(\\mathbb{V}(k + X) = \\mathbb{V}(X)\\), \\(\\mathbb{V}(kX) = k^2\\mathbb{V}(X)\\);\nPara \\(X\\) e \\(Y\\) variáveis independentes, \\(\\mathbb{V}(X \\pm Y) = \\mathbb{V}(X) + \\mathbb{V}(Y)\\);\nÉ sensível aos valores discrepantes e, portanto, só deve ser usada quando a distribuição é simétrica ou aproximadamente simétrica.\n\nPor fim, existe o coeficiente de varição (\\(\\text{cv}\\)), que é uma medida de dispersão em termos de porcentagem da média: \\[\\text{cv} = \\frac{s}{\\bar{x}}\\times 100,\\] em que não há unidade de medida e, portanto, serve como métrica de comparação na variação de variáveis diferentes.\nDentro do R, a função summary() é a chave mestre que calcula quase todas as métricas que foram vistas. Para exemplificar, selecionaremos apenas a variável bill_length do conjunto de dados penguins (Tabela 3.4).\n\npenguins %&gt;% \n  select(bill_length_mm) %&gt;% \n  summary()\n\n\n\n\n\nTabela 3.4: Saída da função summary()\n\n\n\n\n\n\nVariável\nMin\n1º Quad.\nMediana\nMédia\n3º Quad.\nMax\nNAs\n\n\n\n\nbill_length_mm\n32.1\n39.225\n44.45\n43.92193\n48.5\n59.6\n2\n\n\n\n\n\n\n\n\nEnquanto as medidas resumo nos fornecem valores pontuais para compreensão do centro e a dispersão, as tabelas oferecem uma visão panorâmica da distribuição dos dados. Organizar as informações de forma tabular é o primeiro para visualizar as frequências de cada categoria ou intervalo, complementando a análise numérica anterior.\nAs normas gerais para construção de uma tabela envolvem:\n\nDevem ser auto-explicativas.\nDevem conter um título, que precisa ser simples e claro, indicando informações sobre os dados (do que, onde e quando foram coletados – se forem relevantes).\n\nAlém das normas gerais, existem duas convenções importantes a serem seguidas com relação ao título de tabelas e gráficos:\n\nEm tabelas os títulos vem primeiro, em cima da tabela.\nEm gráficos os títulos vem por último, embaixo do gráfico.\n\nSe necessário, notas e fontes vêm embaixo, em ambos os casos. Uma tabela começa e termina com um traço horizontal e traços na vertical devem ser evitados, conforme visto na Tabela 3.1 por exemplo.\nUma forma adequada para resumir informações sobre uma variável numa tabela é através da construção de uma tabela de frequências, que informa quais valores ou categorias a variável pode tomar, com suas respectivas frequências. Quando a variável é qualitativa, as frequências vão revelar se temos categorias mais comuns (típicas) e categorias raras ou se a distribuição é uniforme/homogênea. Já quando a variável é quantitativa, as frequências revelarão os valores típicos e/ou a distribuição dos valores é simétricas ou assimétrica.\nExistem alguns tipos de frequência que podem ser utilizados para resumir as informações, dentre eles:\n\nFrequência absoluta ou simplesmente frequência (\\(f\\)): é a contagem do número de vezes que um valor ou categoria aparece.\nFrequência relativa (\\(\\text{fr} = f/n\\)): quando esse valor é multiplicado por \\(100\\), informa a porcentagem do aparecimento de uma determinada categoria sobre o número total de contagem.\nFrequência acumulada (\\(\\text{fa}\\)): é a frequência acumulada até um valor específico.\nFrequência acumulada relativa (\\(\\text{far} = \\text{fa}/n\\)): quando esse valor é multiplicado por \\(100\\), informa a porcentagem acumulada do aparecimento de uma determinada categoria sobre o número total de contagem.\n\nA Tabela 3.5 contém as informações sobre as frequências de cada espécie de pinguim existente no conjunto de dados penguins. As informações básicas que podem ser extraídas é que entre as espécies dentro do estudo sobre pinguins 44.2% são Adelie, 36% são Gentoo e 19.8% são Chinstrap.\n\n\n\n\nTabela 3.5: Distribuição de frequências para as espécies de Pinguins.\n\n\n\n\n\n\nEspécies\nFrequência\nFrequência absoluta\nPorcentagem\n\n\n\n\nAdelie\n152\n0.442\n44.2\\%\n\n\nGentoo\n124\n0.360\n36\\%\n\n\nChinstrap\n68\n0.198\n19.8\\%\n\n\nTotal\n344\n1.000\n100\\%\n\n\n\n\n\n\n\n\nQuando a variável é quantitativa e assume muitos valores distintos, para resumir e capturar o padrão da distribuição, esses valores devem ser agrupados em intervalos. A quantidade de intervalos é arbitrário, no entanto, não pode ser nem muito baixo e nem muito alto. O próximo passo é especificar os intervalos, contando quantos valores aparecem dentro de cada um deles.\nPara exemplificar, utilizaremos a variável body_mass_g de nosso conjunto de dados sobre os pinguins. Em geral, segue-se os passos:\n\nCalcular a amplitude (\\(A\\)) dos dados.\n\n\npenguins %&gt;% \n  summarise(\n    maior = max(body_mass_g, na.rm = TRUE),\n    menor = min(body_mass_g, na.rm = TRUE),\n    amplitude = max(body_mass_g, na.rm = TRUE) - min(body_mass_g, na.rm = TRUE))\n\n# A tibble: 1 × 3\n  maior menor amplitude\n  &lt;int&gt; &lt;int&gt;     &lt;int&gt;\n1  6300  2700      3600\n\n# Ou ainda\nA &lt;- penguins %&gt;% \n  summarise(\n    amplitude = diff(range(body_mass_g, na.rm = TRUE))\n  )\n\n\nEncontrar o comprimento aproximado de cada intervalo, dividindo \\(A\\) pelo número de intervalos desejados.\n\n\nA/6\n\n  amplitude\n1       600\n\n\nA partir da Tabela 3.6 e pela coluna das frequências relativas, observa-se que a distribuição do peso é assimétrica. Em breve, isso será observado graficamente.\n\n\n\n\nTabela 3.6: Distribuição de frequências para a massa corporal (g) dos pinguins.\n\n\n\n\n\n\nMassa corporal (g)\nFrequência\nf.r. (\\%)\nf.a.r. (\\%)\n\n\n\n\n2700 $\\vdash$ 3300\n34\n9.94\\%\n9.94\\%\n\n\n3300 $\\vdash$ 3900\n110\n32.16\\%\n42.11\\%\n\n\n3900 $\\vdash$ 4500\n80\n23.39\\%\n65.5\\%\n\n\n4500 $\\vdash$ 5100\n60\n17.54\\%\n83.04\\%\n\n\n5100 $\\vdash$ 5700\n41\n11.99\\%\n95.03\\%\n\n\n5700 $\\vdash$ 6300\n17\n4.97\\%\n100\\%\n\n\n\n\n\n\n\n\n\n\n3.2.2 Tipos de gráficos\nAs distribuições de frequências podem ser representadas em gráficos, que facilitam a interpretação visual do comportamento dos dados. Os gráficos mais comuns, segundo o tipo de variável, são:\n\nBarras ou colunas: apropriado para variáveis qualitativas e quantitativas discretas.\nSetores: qualitativas nominais com poucas categorias.\nHistograma: qualitativas contínuas.\nBox-plot: quantitativas.\nDiagrama de dispersão: relaciona duas quantitativas.\nGráfico de linhas: evolução de quantitativa ao longo do tempo ou espaço.\n\nCom esse conhecimento em mente podemos prosseguir para as construções dos gráficos utilizando o ggplot2\n\n3.2.2.1 Visualizando uma única variável\nPara visualizar a distribuição de uma variável contínua como a massa corporal, utiliza-se o histograma com a função geom_histogram(). Como já foi visto, a escolha do número de colunas é arbitrário e pode afetar significativamente a aparência e a interpretação do gráfico.\n\npenguins %&gt;% \n  ggplot(mapping = aes(x = body_mass_g))+\n    geom_histogram(color = \"white\", fill = \"steelblue\",\n                   breaks = seq(2700, 6300, by = 600), \n                   closed = \"left\")+\n    scale_x_continuous(\n      breaks = seq(2700, 6300, by = 600),\n      labels = seq(2700, 6300, by = 600),\n      limits = c(2700, 6300)\n    )+\n    labs(\n      x = \"Massa corporal (g)\",\n      y = \"Contagem\"\n    )+\n    ggthemes::theme_clean()\n\n\n\n\nDistribuição da massa corporal (g) dos pinguins.\n\n\n\n\nObserve que a biblioteca ggthemes foi utilizada para melhorar o aspecto estético do gráfico, fornecendo temas adicionais. Portanto, é recomendável instalá-la e carregá-la no espaço de trabalho.\n\n# install.packages(\"ggthemes\")\nlibrary(ggthemes)\n\nPara variáveis categóricas, como species, usamos o geom_bar() para criar um gráfico de barras que mostra a contagem de observações em cada categoria.\n\npenguins %&gt;% \n  ggplot(mapping = aes(x = species, fill = species))+\n    geom_bar()+\n    labs(\n      x = \"Espécie\",\n      y = \"Número de Indivíduos\"\n    )+\n    labs(\n        x = \"Massa corporal (g)\",\n        y = \"Contagem\",\n        fill = \"Espécies\"\n      )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\nDistribuição de Pinguins por Espécie.\n\n\n\n\n\n\n3.2.2.2 Relações entre variáveis\nO gráfico de dispersão é a ferramenta clássica para explorar relações entre duas variáveis numéricas. Investigaremos a relação existente entre o comprimento da nadadeira e a massa corporal. A hipótese é que pinguins com nadadeiras maiores também serão mais pesados, uma relação positiva e intuitiva que serve como um excelente parâmetro de partida.\n\npenguins %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g))+\n    geom_point()+\n    labs(\n      x = \"Comprimento da Nadadeira (mm)\",\n      y = \"Mass corporal (g)\"\n    )+\n  theme_clean()\n\n\n\n\n\n\n\nFigura 3.1: Relação entre o tamanho da nadadeira (mm) e o peso corporal (g) dos pinguins.\n\n\n\n\n\nA Figura 3.1 informa uma clara tendência positiva entre a nadadeira e o peso corporal dos pinguins. Mas será que esse tendência é a mesma para todas as espécies? Para responder essa pergunta, através da função aes(), é possível adicionar estéticas adicionais como shape, color ou size para distinguir as espécies no gráfico. O argumento a ser utilizado dependerá onde a imagem será utilizada. Por exemplo, em uma revista científica, que solicita gráficos em preto e branco, é aconselhável utilizar shape ou size.\n\npenguins %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g, color = species))+\n    geom_point()+\n    labs(\n      x = \"Comprimento da Nadadeira (mm)\",\n      y = \"Massa corporal (g)\",\n      color = \"Espécies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigura 3.2: Relação entre o tamanho da nadadeira (mm) e o peso corporal (g) por espécie dos pinguins.\n\n\n\n\n\nA Figura 3.2 revela detalhes mais pertinentes, mostrando que a relação entre massa corporal e comprimento da nadadeira mantêm-se positiva (nível de grupo).\nPara comparar a distribuição de uma variável numérica entre diferentes categorias, o boxplot3 (geom_boxplot()) é uma excelente ferramenta. Para isso, vamos comparar a distribuição da massa corporal entre as três espécies.\n\npenguins %&gt;% \n  ggplot(aes(x = species, y = body_mass_g, fill = species))+\n    geom_boxplot()+\n    labs(\n      x = \"Espécies\",\n      y = \"Massa corporal (g)\",\n      fill = \"Espécies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"none\")\n\n\n\n\nBoxplot para a massa corporal (g) por espécies de pinguins.\n\n\n\n\nUma alternativa ao geom_boxplot() é o geom_violin(), que traz um detalhamento sobre os dados de uma maneira mais simples. Adicionalmente, podemos utilizar o geom_jitter() para evitar a sobreposição dos dados, enriquecendo o visual do gráfico.\n\npenguins %&gt;% \n  ggplot(aes(x = species, y = body_mass_g, fill = species))+\n    geom_violin(alpha = 0.5)+\n    geom_jitter(width = 0.1, alpha = 0.5)+\n    labs(\n      x = \"Espécie\",\n      y = \"Massa corporal (g)\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n3.2.3 Técnicas avançadas de visualização e comunicação\nCom a base da construção de gráficos vista anteriormente, é possível explorar técnicas para criar gráficos mais ricos e informativos, complementando informações descobertas de forma eficaz.\n\n\n3.2.4 Sub-gráficos com facet_wrap()\nAs facetas permitem criar uma matriz de gráficos, dividindo os dados com uma base em uma ou mais variáveis categóricas. Isso é extremamente útil para comparações. Para exemplificar, vamos utilizar o gráfico de dispersão e segmentá-lo para a variável sex.\n\npenguins %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  mutate(\n  sex = recode(sex,\n         \"female\" = \"Fêmea\",\n         \"male\" = \"Macho\")\n  ) %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g, color = species))+\n    geom_point()+\n    facet_wrap(~ sex)+\n    labs(\n      x = \"Comprimento da nadadeira (mm)\",\n      y = \"Massa corporal (g)\",\n      color = \"Espécies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\nDistribuição de massa corporal (g) por espécie.\n\n\n\n\nNeste gráfico, fica evidente que os pinguins fêmeas possuem menos massa corporal que os machos e, quanto as espécies, Gentoo é que concentra a maior massa. Contudo, pode ser do interesse do pesquisador além de verificar a massa corporal por sexo, também incluir a variável island.\n\npenguins %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  mutate(\n  sex = recode(sex,\n         \"female\" = \"Fêmea\",\n         \"male\" = \"Macho\")\n  ) %&gt;% \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g, color = species))+\n    geom_point()+\n    facet_wrap(island ~ sex)+\n    labs(\n      x = \"Comprimento da nadadeira (mm)\",\n      y = \"Massa corporal (g)\",\n      color = \"Espécies\"\n    )+\n    theme_clean()+\n    theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigura 3.3: Distribuição de massa corporal (g) nas ilhas por espécie.\n\n\n\n\n\nA partir da Figura 3.3 é possível reparar que nem todas as espécies estão presentes nas três ilhas simultaneamente. Além disso, a ilha de Biscoe é a que apresenta o maior percentual de massa corporal dos pinguins, isto é, a espécie Gentoo é a predominante.\n\n\n\n\nGORMAN, Kristen B. et al. Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLOS ONE, v. 9, n. 3, p. e90081, 2014.\n\n\nWICKHAM, Hadley. Tidy Data. Journal of Statistical Software, v. 59, p. 1–23, set. 2014.\n\n\nWICKHAM, Hadley. Ggplot2. Cham: Springer International Publishing, 2016.\n\n\nWICKHAM, Hadley et al. Welcome to the Tidyverse. Journal of Open Source Software, v. 4, n. 43, p. 1686, nov. 2019.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "03-tidyverse.html#footnotes",
    "href": "03-tidyverse.html#footnotes",
    "title": "3  Tidyverse",
    "section": "",
    "text": "A partir da versão 4.1 do R, existe também o operador pipe nativo |&gt;. No entanto, nesta apostila manteremos o uso de %&gt;%, amplamente adotado no contexto do tidyverse.↩︎\nTente contar os números do conjunto \\(A = \\{1,2,3,4\\}\\) e, também, de \\(B = [1,4]\\). Observe que no conjunto \\(A\\) há 4 elementos, enquanto em \\(B\\) há infinitos valores de 1 a 4.↩︎\nTambém chamado por gráfico de caixas.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tidyverse</span>"
    ]
  },
  {
    "objectID": "04-pratica.html",
    "href": "04-pratica.html",
    "title": "4  Prática",
    "section": "",
    "text": "4.1 Classificação: Pinguins do arquipélago Palmer\nNeste capítulo será aplicaremos os conceitos vistos de ML e R para ….",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Prática</span>"
    ]
  },
  {
    "objectID": "04-pratica.html#classificação-pinguins-do-arquipélago-palmer",
    "href": "04-pratica.html#classificação-pinguins-do-arquipélago-palmer",
    "title": "4  Prática",
    "section": "",
    "text": "4.1.1 Conheça os pinguins 🐧\n\n\n\nObra de @allison_horst.\n\n\nOs palmerpenguinsdados contêm medições de tamanho de três espécies de pinguins observadas em três ilhas no Arquipélago Palmer, na Antártida.\n\nlibrary(palmerpenguins)\n\n\nAnexando pacote: 'palmerpenguins'\n\n\nO seguinte objeto é mascarado por 'package:modeldata':\n\n    penguins\n\n\nOs seguintes objetos são mascarados por 'package:datasets':\n\n    penguins, penguins_raw\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\n\n4.1.2 Usando head()\n\n#|echo: true\n\nUsar head() pode ser interessante para ter um primeiro olhar para os dados:\n\nhead(penguins)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n4.1.3 Usando arrange()\narrange() organiza nossos dados em ordem crescente, partindo do menor valor da variável de interesse até o maior (ou em caso da variável ver qualitativa, será apresentado em ordem alfabética).\n\npenguins %&gt;%\n  arrange(bill_length_mm) %&gt;%\n  head()\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Dream               32.1          15.5               188        3050\n2 Adelie  Dream               33.1          16.1               178        2900\n3 Adelie  Torgersen           33.5          19                 190        3600\n4 Adelie  Dream               34            17.1               185        3400\n5 Adelie  Torgersen           34.1          18.1               193        3475\n6 Adelie  Torgersen           34.4          18.4               184        3325\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n4.1.4 Criando um subconjunto com subset()\n\n\n4.1.5 Aplicação de um modelo de classificação\n\n# Carregando os pacotes\nlibrary(tidymodels)\n\n\n\n# Usar o dataset iris, disponível por padrão no R\ndata(iris)\n\n# Criar um split treino/teste\nset.seed(123)\nsplit &lt;- initial_split(iris, prop = 0.8)\ntrain &lt;- training(split)\ntest &lt;- testing(split)\n\n# Definir o modelo (regressão logística multinomial)\nmodelo &lt;- multinom_reg() %&gt;%\n  set_engine(\"nnet\") %&gt;%\n  set_mode(\"classification\")\n\n# Criar o workflow\nworkflow &lt;- workflow() %&gt;%\n  add_model(modelo) %&gt;%\n  add_formula(Species ~ .)\n\n# Ajustar o modelo\najustado &lt;- fit(workflow, data = train)\n\n# Previsão e avaliação\npred &lt;- predict(ajustado, new_data = test) %&gt;%\n  bind_cols(test)\n\n# Métricas de desempenho\nmetrics(pred, truth = Species, estimate = .pred_class)\n\n# A tibble: 2 × 3\n  .metric  .estimator .estimate\n  &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;\n1 accuracy multiclass     0.967\n2 kap      multiclass     0.946\n\n# Matriz de confusão\nconf_mat(pred, truth = Species, estimate = .pred_class)\n\n            Truth\nPrediction   setosa versicolor virginica\n  setosa         10          0         0\n  versicolor      0         14         0\n  virginica       0          1         5",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Prática</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "GORMAN, Kristen B. et al. Ecological\nSexual Dimorphism and Environmental\nVariability within a Community of Antarctic\nPenguins (Genus Pygoscelis). PLOS\nONE, v. 9, n. 3, p. e90081, 2014.\n\n\nWICKHAM, Hadley. Tidy\nData. Journal of Statistical Software,\nv. 59, p. 1–23, set. 2014.\n\n\nWICKHAM, Hadley. Ggplot2.\nCham: Springer International Publishing, 2016.\n\n\nWICKHAM, Hadley et al. Welcome to the\nTidyverse. Journal of Open Source\nSoftware, v. 4, n. 43, p. 1686, nov. 2019.",
    "crumbs": [
      "References"
    ]
  }
]